<!DOCTYPE html>
<html lang="en">

<head>
	<title>Prelude to an Oral Exam</title>

	<meta property="og:title" content="Prelude to an Oral Exam"/>
	<meta property="og:type" content="website"/>
	<meta property="og:url" content="https://cruzgodar.com/slides/oral-exam/"/>
	<meta property="og:image" content="https://cruzgodar.com/slides/oral-exam/cover.webp"/>
	<meta property="og:locale" content="en_US"/>
	<meta property="og:site_name" content="Cruz Godar"/>

	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
	<meta id="theme-color-meta" name="theme-color" content="#181818">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Rubik&display=swap" rel="stylesheet" as="font">

	<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	
	<link rel="stylesheet" type="text/css" href="/style/wilson.min.css">
	<link rel="stylesheet" type="text/css" href="/style/lapsa.min.css">
	
	<link rel="stylesheet" type="text/css" href="/style/lapsa-dark.css">

	<style>
		#young-diagram-example #numbers-canvas-container, #regions-example #numbers-canvas-container
		{
			opacity: 0 !important;
		}
	</style>
</head>

<body>
	<div id="lapsa-slide-container">
		<div id="title" class="medium-canvas">
			<h1>Prelude to an Oral Exam</h1>
			
			<h2>Cruz Godar</h2>
			
			<p class="lapsa-align-bottom">Made with <a href="/about/index.html"><img class="inline-image" src="/graphics/general-icons/heart.webp"></img></a> and <a href="/slides/lapsa/index.html"><img class="inline-image" src="/graphics/general-icons/lapsa.webp"></img></a></p>

			<div id="canvas-bundle" style="opacity: 0">
				<div>
					<div style="position: absolute; width: 100%">
						<canvas id="output-canvas"></canvas>
					</div>
					
					<div id="numbers-canvas-container" style="width: 100%">
						<canvas id="numbers-canvas" style="opacity: 0"></canvas>
					</div>
				</div>
			</div>
		</div>
		
		
		
		<div>
			<h1>Background</h1>
			
			<p class="build">A <dfn>partition</dfn> of an integer $n$ is a sequence $(a_1, a_2, ... )$ of decreasing nonnegative integers $a_i$ with $\sum_i a_i = n$.</p>
			
			<p class="build">Ex: $(5, 3, 2, 2, 1, 0, 0, ...)$ is a partition of $13$.</p>
			
			<p class="build">The <dfn>Young diagram</dfn> corresponding to a partition $(a_i)$ is the set $\{(i, j) \in \mathbb{N}^2 \mid 1 \leq j \leq a_i\}$.</p>
			
			<p class="build">We usually treat these as top-left-justified sets of squares in a grid, so that $a_i$ is the length of row $i$.</p>
		</div>
		
		
		
		<div id="young-diagram-example" class="large-canvas">
			<p>Ex: the Young diagram of $(5, 3, 2, 2, 1, 0, 0, ...)$.</p>
		</div>
		
		
		
		<div>
			<h1>Plane Partitions</h1>
			
			<p class="build">A <dfn>plane partition</dfn> is a placement of nonnegative integers into a Young diagram, such that the rows and columns weakly decrease. We can also think of them as a stacks of boxes, with each number indicating how many boxes are stacked on that square.</p>
			
			<p class="build">The <dfn>weight</dfn> of a plane partition $\pi$, written $|\pi|$, is just the sum of its entries, or equivalently the total number of boxes stacked.</p>
			
			<p class="build">If we require the rows and columns of a plane partition to weakly <em>increase</em> rather than decrease, the resulting object is called a <dfn>reverse plane partition</dfn>, or RPP.</p>
		</div>
		
		
		
		<div id="plane-partition-example" class="large-canvas">
			<p>Ex: a plane partition of weight $33$.<p>
		</div>
		
		
		
		<div>
			<h1>Hooks and Hook Lengths</h1>
			
			<p class="build">The <dfn>hook</dfn> corresponding to a box in a plane partition is the right-angled collection of boxes directly above and to the left of it. The hook length $h(i, j)$ of a box is the total number of boxes in its hook, and the corner box $(i, j)$ is called the <dfn>pivot</dfn> of the hook.</p>
			
			<p class="build">In an RPP, the direction of hooks is reserved along with the inequalities, and they extend down and right instead.</p>
		</div>
		
		
		
		<div id="hooks" class="large-canvas">
			<p>Ex: $h(2, 1) = 5$ in this RPP.</p>
		</div>
		
		
		
		<div>
			<h1>A Generating Function for RPPs</h1>
			
			<p class="build">A famous result (due to Stanley in his Ph.D. thesis) expresses the generating function for RPPs of shape $\lambda$ as a product involving hook lengths:</p>
			
			<p class="build" style="text-align: center"><strong>Thm:</strong> $\displaystyle \sum_\pi q^{|\pi|} = \prod_{(i, j) \in \lambda} \frac{1}{1 - q^{h(i, j)}},$</p>
			
			<p data-build="1">where the sum is taken over all RPPs $\pi$ of shape $\lambda$. Since boxes and hooks are in bijection, the combinatorial interpretation is that RPPs of shape $\lambda$ are in bijection with multi-sets of hooks in a diagram of shape $\lambda$.</p>
		</div>
		
		
		
		<div>
			<h1>Hillman-Grassl</h1>
			
			<p class="build">The first bijective proof of the hook length formula is due to Hillman and Grassl in 1975. Given a multi-set of hooks, it is not possible to place them unmodified to construct an RPP: for example, with $\lambda = (2, 2)$, the hook with pivot $(1, 1)$ makes the tableau</p>
			
			<p data-build="0" style="text-align: center">$\begin{array}{cc}1 & 1 \\ 1 & 0\end{array}$</p>
			
			<p data-build="0">which isn&#x2019;t a valid RPP.</p>
		</div>
		
		
		
		<div>
			<h1>Zigzag Paths</h1>
			
			<p>The Hillman-Grassl map decomposes RPPs into <dfn>zigzag paths</dfn> instead of hooks. A zigzag path begins at the leftmost nonzero entry at the bottom of its column. It moves up if the entries are equal and right otherwise, until it can no longer move.</p>
			
			<p class="build">The <dfn>pivot</dfn> of a zigzag path is the entry with the path&#x2019;s starting column and ending row.</p>
			
			<p class="build">Every nonzero RPP has a unique zigzag path, and decrementing its entries preserves the RPP inequalities. Critically, every zigzag path has length equal to its pivot&#x2019;s hook length.</p>
		</div>
		
		
		
		<div id="zigzag-paths" class="full-square-canvas"></div>
		
		
		
		<div>
			<p>The Hillman-Grassl map $\operatorname{HG}$ is a bijection between RPPs and multisets of hooks. It operates on an RPP by decrementing its zigzag path, finding the zigzag path of the resulting RPP and decrementing <em>it</em>, and so on, until eventually the RPP has weight zero. At each step, we record the corresponding hook formed.</p>
			
			<p class="build">The removal of a zigzag path is an invertible operation, and it can be shown that the generated sequence of pivots respects a reverse lexicographic ordering, so given a multiset of pivots, the inverse map $\operatorname{HG}^{-1}$ is well-defined.</p>
			
			<p class="build">Since hooks are in bijection with pivots, we can concisely represent the multiset of hooks as a tableau of shape $\lambda$, weighted by hook length.</p>
		</div>
		
		
		
		<div id="hillman-grassl" class="full-square-canvas"></div>
		
		
		
		<div>
			<h1>Pak</h1>
			
			<p>In 2002, Igor Pak found a different bijection between RPPs and multisets of hooks. In contrast to Hillman-Grassl, Pak&#x2019;s bijection operates on the level of boxes rather than hooks.</p>
			
			<p>For ease of notation, let $\lambda$ be a partition and $x \in \lambda$ (i.e. a box in the Young diagram), and define $\mathbf{n}x$, $\mathbf{s}x$, $\mathbf{e}x$, and $\mathbf{w}x$ to be the boxes above, below, right, and left of $x$, respectively.</p>
		</div>
		
		
		
		<div>
			<p>Given an RPP $\pi$, select an outer corner of the diagram and call it $y$. For every $x$ in the same diagonal as $y$ other than $y$ itself, define the <dfn>toggle</dfn> of $\pi(x)$ to be</p>
			
			<p style="text-align: center">$\displaystyle \pi'(x) = \max(\pi(\mathbf{n}x), \pi(\mathbf{w}x)) + \min(\pi(\mathbf{s}x), \pi(\mathbf{e}x)) - \pi(x).$</p>
			
			<p class="build">In other words, the toggle of $\pi(x)$ is the max of the adjacent entries smaller than it, plus the min of the adjacent entries larger than it, minus itself.</p>
			
			<p class="build">We now replace $\pi(x)$ with $\pi'(x)$ for all $x$ in the diagonal, excluding $y$.</p>
		</div>
		
		
		
		<div>
			<p>We handle the outer corner $y$ differently: it is completely removed from $\pi$, and the value</p>
			
			<p style="text-align: center">$\displaystyle \pi(y) - \max(\pi(\mathbf{n}y), \pi(\mathbf{w}y)),$</p>
			
			<p>which is how much larger $\pi(y)$ is than strictly necessary, is stored in a tableau at the same location. The shape of the RPP is now one box smaller, and we repeat the previous procedure, choosing a new outer corner, until the RPP is empty.</p>
			
			<p class="build">The RPP in the next animation has been rotated 180$^\circ$, so outer corners are in the top-left. For clarity, toggled corners remain in the same diagram, but they are given color.</p>
		</div>
		
		
		
		<div id="pak" class="full-square-canvas"></div>
		
		
		
		<div>
			<p>It can be shown that the order in which corners are chosen does not impact the final result of Pak, and (more easily) that entries in the output tableau contribute weight equal to their hook length.</p>
			
			<p class="build">Toggling a non-corner entry is an involution, and knowing the entry recorded to the tableau from a toggled corner lets us recover the corner&#x2019;s entry in the RPP. Therefore, the inverse bijection is well-defined.</p>
			
			<p class="build">While the algorithm is simple enough, the fact that it outputs multisets of hooks seems to hint at a description closer in style to Hillman-Grassl.</p>
		</div>
		
		
		
		<div>
			<h1>Sulzgruber</h1>
			
			<p class="build">In 2017, Robin Sulzgruber found exactly that: an equivalent formulation of Pak&#x2019;s bijection that removes one hook at a time.</p>
			
			<p class="build">Given a partition $\lambda$, we divide its Young diagram into four regions:</p>
			
			<p class="build">$\mathcal{O}$ consists of diagonals ending in an outer corner.</p>
			
			<p data-build="2">$\mathcal{I}$ consists of diagonals ending in an inner corner.</p>
			
			<p data-build="2">$\mathcal{A}$ consists of diagonals ending in a horizontal edge.</p>
			
			<p data-build="2">$\mathcal{B}$ consists of diagonals ending in a vertical edge.</p>
		</div>
		
		
		
		<div id="regions-example" class="full-square-canvas"></div>
		
		
		
		<div>
			<p>Given an RPP $\pi$, we define the set of <dfn>candidates</dfn> $C(\pi)$ to be the cells $x \in \mathcal{O}$ with $\pi(\mathbf{w}u) < \pi(u)$, along with the cells $x \in \mathcal{A}$ with $\pi(\mathbf{w}u) < \pi(u) > \pi(\mathbf{n}u)$.</p>
			
			<p class="build">We select the minimum candidate $x$ with respect to content order &mdash; that is, whose diagonal is as north-east as possible, with preference within a diagonal given to the south-east end. With $x$ as a starting position, we build a path as follows:</p>
			
			<p class="build">If the current cell $x$ belongs to $\mathcal{O} \cup \mathcal{B}$ and $\pi(\mathbf{nx}) = \pi(x)$, we move one cell north. Otherwise, we move cell east unless that move leaves the diagram, in which case we stop. As with Hillman-Grassl, we decrement this path, store its pivot in a tableau, and repeat until the RPP is empty.</p>
		</div>
		
		
		
		<div id="sulzgruber" class="full-square-canvas"></div>
		
		
		
		<div id="ps-rsk" class="medium-canvas">
			<p class="left-text">Incredibly, Pak and Sulzgruber&#x2019;s maps produce identical results despite wildly differing descriptions. We refer to the map collectively as $\operatorname{PS}$.</p>
			
			<p class="build left-text">There is a surprising connection between $\operatorname{PS}$ and the $\operatorname{RSK}$ algorithm. Given a square tableau $T$, the diagonals of $\operatorname{PS}^{-1}(T)$ give the shapes of restrictions of $P$ and $Q$ in $(P, Q) = \operatorname{RSK}(T)$.</p>
		</div>
		
		
		
		<div id="garver-patrias" class="medium-canvas">
			<h1>Garver-Patrias</h1>
			
			<p class="left-text">This result is stated in a different but equivalent manner in a paper by Garver and Patrias. Given a Young diagram of shape $\lambda$, we first label each box in reading order.</p>
		</div>
		
		
		
		<div id="garver-patrias-2" class="medium-canvas">
			<p class="left-text">Given a tableau $T$ of shape $\lambda$, which is equivalent to a multiset of hooks, we write them in the order the Sulzgruber algorithm inserts them, and then read off the labels of their pivots to form a word $w$. In this example, $w = 145539$.</p>
		</div>
		
		
		
		<div id="garver-patrias-3" class="medium-canvas">
			<p class="left-text">For each diagonal $d$, we form the subword $w_d$ of $w$ by selecting only the labels whose hooks intersect diagonal $d$.</p>
			
			<p class="left-text">Here, $w_{-2} = 14$, $w_{-1} = 1455$, $w_0 = 145539$, $w_1 = 14553$, and $w_2 = 13$.</p>
		</div>
		
		
		
		<div id="garver-patrias-4" class="medium-canvas">
			<p class="left-text">We now run $\operatorname{RSK}$ on each $w_d$ and store the shape of the resulting tableaux in the corresponding diagonal.</p>
			
			<p class="left-text build">For example, the tableau $P$ in $\operatorname{RSK}(w_1) = \operatorname{RSK}(14355)$ is</p>
			
			<p data-build="0" class="left-text" style="text-align: center">$\displaystyle\begin{array}{cccc}1 & 3 & 5 & 5 \\ 4\end{array},$</p>
			
			<p data-build="0" class="left-text">so we place the partition $(4, 1)$ into the diagonal $d = 1$ (in reverse order).</p>
		</div>
		
		
		
		<div>
			<p><strong>Thm:</strong> This process is equivalent to $\operatorname{PS}$.</p>
			
			<p class="build">We can describe $\operatorname{HG}$ in an identical way by changing the labeling order to be right to left, top to bottom, and then changing the hook ordering to match $\operatorname{HG}$&#x2019;s insertion order. The result is a much more clear connection between the two bijections.</p>
		</div>
		
		
		
		<div>
			<h1>What&#x2019;s the Use?</h1>
			
			<p class="build">My research uses these bijections in order to develop new ones between generalizations of plane partitions. A central result deals with plane partitions <dfn>asymptotic</dfn> to a Young diagram $\lambda$, which are analogous to skew semi-standard Young tableaux.</p>
		</div>
		
		
		
		<div id="app" class="large-canvas">
			<p>Ex: a plane partition asymptotic to $\lambda = (3, 2)$.</p>
		</div>
		
		
		
		<div>
			<p><strong>Thm:</strong> With $\operatorname{M}(q)$, $\operatorname{RPP}_\lambda(q)$, and $\operatorname{APP}_\lambda(q)$ denoting the generating functions for plane partitions, RPPs of shape $\lambda$, and plane partitions asymptotic to lambda, respectively,</p>
			
			<p style="text-align: center">$\displaystyle \operatorname{APP}_\lambda(q) = \operatorname{RPP}_\lambda(q)M(q)$.</p>
			
			<p>This relation was formerly known only algebraically, but showing it bijectively was possible using $\operatorname{HG}$. A generalization of the relation was also bijectivized using Pak, and a bijectivizing a further generalization, which was shown algebraically by Jenne, Webb, and Young in 2020, remains an open problem.</p>
		</div>
		
		
		
		<div style="display: flex; flex-direction: column; justify-content: center">
			<h1 style="text-align: center">That&#x2019;s all for now, folks!</h1>
		</div>
	</div>

	<script>
		window.MathJax =
		{
			tex:
			{
				inlineMath: [["$", "$"], ["\\(", "\\)"]]
			}
		};
	</script>

	<script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
	
	<script src="index.js" type="module"></script>
</body>

</html>