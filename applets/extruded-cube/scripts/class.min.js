import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class ExtrudedCube extends RaymarchApplet{constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:`
			float scaleCenter = (scale + 1.0) / (scale - 1.0) * separation;

			pos = abs(pos);

			float totalDistance = (max(max(pos.x, pos.y), pos.z) - 1.0);

			for (int iteration = 0; iteration < maxIterations; iteration++)
			{
				if (iteration == iterations)
				{
					break;
				}

				if (pos.x > max(pos.y, pos.z))
				{
					pos = scale * pos - (scale - 1.0) * vec3(scaleCenter, 0.0, 0.0);
				}

				else if (pos.y > max(pos.x, pos.z))
				{
					pos = scale * pos - (scale - 1.0) * vec3(0.0, scaleCenter, 0.0);
				}

				else
				{
					pos = scale * pos - (scale - 1.0) * vec3(0.0, 0.0, scaleCenter);
				}

				pos = abs(pos);

				totalDistance = min(
					totalDistance,
					(max(max(pos.x, pos.y), pos.z) - 1.0)
						/ pow(scale, float(iteration + 1))
				);
			}
			
			return totalDistance;
		`,getColorGlsl:`	
			vec3 color = vec3(0.25);

			float scaleCenter = (scale + 1.0) / (scale - 1.0) * separation;

			pos = abs(pos);

			for (int iteration = 0; iteration < maxIterations; iteration++)
			{
				if (iteration == iterations)
				{
					break;
				}

				if (pos.x > max(pos.y, pos.z))
				{
					pos = scale * pos - (scale - 1.0) * vec3(scaleCenter, 0.0, 0.0);

					color += vec3(0.0, 0.75, 1.0) * pow(2.0, -float(iteration + 1));
				}

				else if (pos.y > max(pos.x, pos.z))
				{
					pos = scale * pos - (scale - 1.0) * vec3(0.0, scaleCenter, 0.0);

					color += vec3(0.75, 0.0, 1.0) * pow(2.0, -float(iteration + 1));
				}

				else
				{
					pos = scale * pos - (scale - 1.0) * vec3(0.0, 0.0, scaleCenter);

					color += vec3(0.0, 0.0, 1.0) * pow(2.0, -float(iteration + 1));
				}

				pos = abs(pos);
			}
			
			return color;
		`,addGlsl:`
			const int maxIterations = 32;
		`,uniformsGlsl:`
			uniform int iterations;
			uniform float scale;
			uniform float separation;
		`,uniforms:{iterations:16,scale:3,separation:1},cameraPos:[2.41322,2.41439,2.3916],theta:1.25*Math.PI,phi:2.1539})}distanceEstimator(x,y,z){var a=this.uniforms.scale,s=this.uniforms.separation,t=this.uniforms.iterations,e=(a+1)/(a-1)*s;let o=[Math.abs(x),Math.abs(y),Math.abs(z)],i=Math.max(Math.max(o[0],o[1]),o[2])-1;for(let r=0;r<t;r++)o=o[0]>Math.max(o[1],o[2])?[a*o[0]-(a-1)*e,a*o[1],a*o[2]]:o[1]>Math.max(o[0],o[2])?[a*o[0],a*o[1]-(a-1)*e,a*o[2]]:[a*o[0],a*o[1],a*o[2]-(a-1)*e],o=[Math.abs(o[0]),Math.abs(o[1]),Math.abs(o[2])],i=Math.min(i,(Math.max(Math.max(o[0],o[1]),o[2])-1)/Math.pow(a,r+1));return Math.abs(i)}}export{ExtrudedCube};