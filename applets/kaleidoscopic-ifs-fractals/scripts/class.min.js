import{getVectorGlsl}from"/scripts/applets/applet.min.js";import{dotProduct,mat3TimesVector,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";import{changeOpacity}from"/scripts/src/animation.min.js";const ns={tetrahedron:[[-.57735,0,.816496],[.288675,-.5,.816496],[.288675,.5,.816496]],cube:[[1,0,0],[0,1,0],[0,0,1]],octahedron:[[.707107,0,.707107],[0,.707107,.707107],[-.707107,0,.707107],[0,-.707107,.707107]],dodecahedron:[[.809016,-.5,.309017],[.309017,.809016,-.5],[-.5,.309017,.809016],[.809016,-.5,.309017],[.309017,.809016,-.5],[-.5,.309017,.809016],[.809016,-.5,.309017]],icosahedron:[[0,1,0],[-.5,-.309017,.809016],[.5,-.309017,.809016],[-.809016,.5,.309017],[.809016,.5,.309017],[0,1,0]]},scaleCenters={tetrahedron:[0,0,1],cube:[.57735,.57735,.57735],octahedron:[0,0,1],dodecahedron:[.57735,.57735,.57735],icosahedron:[0,.525731,.850651]};function getDistanceEstimatorGlsl(shape,useForGetColor=!1){const t=shape.charAt(0).toUpperCase()+shape.slice(1);var e=ns[shape].length,e=Array(e).fill(0).map((_,i)=>useForGetColor?`
				float t${i} = dot(pos, n${i}${t});
				
				if (t${i} < 0.0)
				{
					pos -= 2.0 * t${i} * n${i}${t};
					color = mix(color, color${i}, colorScale);
				}
			`:`
			float t${i} = dot(pos, n${i}${t});
			
			if (t${i} < 0.0)
			{
				pos -= 2.0 * t${i} * n${i}${t};
			}
		`).join("\n");return`
		${useForGetColor?"vec3 color = vec3(1.0, 1.0, 1.0); float colorScale = .5;":""}
		//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.
		for (int iteration = 0; iteration < 72; iteration++)
		{
			if (iteration >= numIterations)
			{
				break;
			}

			${e}
			
			//Scale the system -- this one takes me a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.
			pos = scale * pos - (scale - 1.0) * scaleCenter${t};
			
			pos = rotationMatrix * pos;

			${useForGetColor?"colorScale *= .5;":""}
		}
		
		return ${useForGetColor?"color":"length(pos) * pow(1.0 / scale, float(numIterations))"};
	`}class KaleidoscopicIFSFractals extends RaymarchApplet{shape="octahedron";constructor({canvas,shape="octahedron"}){var t=[];for(const s in ns){const a=s.charAt(0).toUpperCase()+s.slice(1);var e=Array(ns[s].length).fill(0).map((_,i)=>`
					const vec3 n${i}${a} = ${getVectorGlsl(ns[s][i])};
				`).join("\n")+`
				const vec3 scaleCenter${a} = ${getVectorGlsl(scaleCenters[s])};
			`;t.push(e)}var o=`
			const vec3 color0 = vec3(1.0, 0.0, 0.0);
			const vec3 color1 = vec3(0.0, 1.0, 0.0);
			const vec3 color2 = vec3(0.0, 0.0, 1.0);
			const vec3 color3 = vec3(1.0, 1.0, 0.0);
			const vec3 color4 = color0;
			const vec3 color5 = color1;
			const vec3 color6 = color2;
			const vec3 color7 = color3;
			const vec3 color8 = color0;
			const vec3 color9 = color1;
			
			${t.join("\n")}
		`;super({canvas:canvas,distanceEstimatorGlsl:getDistanceEstimatorGlsl(shape),getColorGlsl:getDistanceEstimatorGlsl(shape,!0),uniformsGlsl:`
			uniform float scale;
			uniform mat3 rotationMatrix;
			uniform int numIterations;
		`,addGlsl:o,uniforms:{scale:2,rotationMatrix:[[1,0,0],[0,1,0],[0,0,1]],numIterations:56},theta:.2004,phi:1.6538,cameraPos:[-2.03816,-.526988,.30503],lightPos:[-50,-70,100],lightBrightness:1.25,epsilonScaling:1,stepFactor:.6}),this.shape=shape}distanceEstimator(x,y,z){var e=ns[this.shape??"octahedron"],o=scaleCenters[this.shape??"octahedron"];for(let t=0;t<this.uniforms.numIterations;t++){for(let t=0;t<e.length;t++){var s=dotProduct([x,y,z],e[t]);s<0&&(x-=2*s*e[t][0],y-=2*s*e[t][1],z-=2*s*e[t][2])}x=this.uniforms.scale*x-(this.uniforms.scale-1)*o[0],y=this.uniforms.scale*y-(this.uniforms.scale-1)*o[1],z=this.uniforms.scale*z-(this.uniforms.scale-1)*o[2],[x,y,z]=mat3TimesVector(this.uniforms.rotationMatrix,[x,y,z])}return Math.sqrt(x*x+y*y+z*z)*Math.pow(this.uniforms.scale,-this.uniforms.numIterations)}async changePolyhedron(newShape){await changeOpacity({element:this.canvas,opacity:0}),this.shape=newShape;var t=getDistanceEstimatorGlsl(this.shape),e=getDistanceEstimatorGlsl(this.shape,!0);this.reloadShader({distanceEstimatorGlsl:t,getColorGlsl:e}),await changeOpacity({element:this.canvas,opacity:1})}}export{KaleidoscopicIFSFractals};