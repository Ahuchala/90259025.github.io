import{generateRandomPlanePartition,generateRandomTableau}from"./generateRandomData.min.js";import{parseArray,verifyPp,verifySsyt}from"./parseAndVerify.min.js";async function runExample(index){if(1===index||2===index){for(;1<this.arrays.length;)await this.removeArray(1),await new Promise(resolve=>setTimeout(resolve,this.animationTime/2));var e;0===this.arrays.length?(e=parseArray(generateRandomPlanePartition()),await this.addNewArray(this.arrays.length,e)):verifyPp(this.arrays[0].numbers)||(await this.removeArray(0),await new Promise(resolve=>setTimeout(resolve,this.animationTime/2)),e=parseArray(generateRandomPlanePartition()),await this.addNewArray(this.arrays.length,e)),1===index?(await this.runAlgorithm("hillmanGrassl",0),await new Promise(resolve=>setTimeout(resolve,3*this.animationTime)),await this.runAlgorithm("hillmanGrasslInverse",0)):(await this.runAlgorithm("pak",0),await new Promise(resolve=>setTimeout(resolve,3*this.animationTime)),await this.showHexView(),await new Promise(resolve=>setTimeout(resolve,this.animationTime)),await this.runAlgorithm("sulzgruberInverse",0))}else if(3===index){for(;0<this.arrays.length;)await this.removeArray(0),await new Promise(resolve=>setTimeout(resolve,this.animationTime/2));await this.addNewArray(this.arrays.length,generateRandomTableau()),await this.show2dView(),await new Promise(resolve=>setTimeout(resolve,this.animationTime)),await this.runAlgorithm("rskInverse",0),await new Promise(resolve=>setTimeout(resolve,3*this.animationTime)),await this.runAlgorithm("rsk",0)}}async function runAlgorithm(name,index,subAlgorithm=!1){if(subAlgorithm||!this.currentlyRunningAlgorithm){this.currentlyRunningAlgorithm=!0;var i=this.algorithmData[name],a=i.inputType.length;if(index>this.arrays.length-1||index<0)console.log(`No array at index ${index}!`),this.currentlyRunningAlgorithm=!1;else if(1<a&&index>this.arrays.length-a)console.log(`No array at index ${index+a-1}! (This algorithm needs ${a} arrays)`),this.currentlyRunningAlgorithm=!1;else{for(let e=0;e<a;e++){var t=i.inputType[e];if("pp"===t&&!verifyPp(this.arrays[index+e].numbers))return console.log(`Array at index ${index+e} is not a plane partition!`),void(this.currentlyRunningAlgorithm=!1);if("ssyt"===t&&!verifySsyt(this.arrays[index+e].numbers))return console.log(`Array at index ${index+e} is not an SSYT!`),void(this.currentlyRunningAlgorithm=!1)}if(1<a&&void 0!==i.sameShape&&i.sameShape){var n=new Array(a);let i=0;for(let e=0;e<a;e++)i=Math.max(i,this.arrays[index+e].numbers.length);for(let t=0;t<a;t++){n[t]=new Array(i);for(let e=0;e<i;e++)n[t][e]=0;for(let r=0;r<this.arrays[index+t].numbers.length;r++){let e=0;for(;e<this.arrays[index+t].numbers[r].length&&0!==this.arrays[index+t].numbers[r][e];)e++;n[t][r]=e}}for(let r=1;r<a;r++)for(let e=0;e<i;e++)if(n[r][e]!==n[0][e])return this.displayError("Arrays are not the same shape!"),void(this.currentlyRunningAlgorithm=!1)}for(let r=0;r<a;r++){var s=[],o=this.arrays[index+r].numbers;for(let i=0;i<o.length;i++)for(let r=0;r<o.length;r++)if(o[i][r]!==1/0)for(let e=0;e<o[i][r];e++)s.push([i,r,e]);this.uncolorCubes(this.arrays[index+r],s)}await i.method.bind(this)(index),this.subAlgorithm||(this.currentlyRunningAlgorithm=!1)}}}export{runExample,runAlgorithm};