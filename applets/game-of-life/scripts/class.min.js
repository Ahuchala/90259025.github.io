import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class GameOfLife extends AnimationFrameApplet{wilsonUpscale;gridSize=100;resolution=1e3;framesPerUpdate=10;updatesPerFrame=1;frame=0;onTorus=!1;currentFramebuffer="0";pauseUpdating=!0;constructor({canvas}){super(canvas);var e=this.createHiddenCanvas(),t={shaders:{noUpdate:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			uniform float stepSize;
			
			
			
			void main(void)
			{
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;
				
				if (center.x <= stepSize || center.x >= 1.0 - stepSize || center.y <= stepSize || center.y >= 1.0 - stepSize)
				{
					gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
					return;
				}

				vec4 thisPixel = texture2D(uTexture, center);

				float state = thisPixel.z;

				gl_FragColor = vec4(0.0, state, state, 1.0);
			}
		`,update:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			uniform float stepSize;
			uniform int onTorus;

			const float glowChangeSpeed = 0.15;
			
			vec2 getModdedPos(vec2 xy)
			{
				return mod(xy - vec2(stepSize), 1.0 - 2.0 * stepSize) + vec2(stepSize);
			}
			
			void main(void)
			{
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;
				
				if (center.x <= stepSize || center.x >= 1.0 - stepSize || center.y <= stepSize || center.y >= 1.0 - stepSize)
				{
					gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
					return;
				}

				vec4 thisPixel = texture2D(uTexture, center);

				float state = thisPixel.z;

				float surroundingState;

				if (onTorus != 0)
				{
					surroundingState = (
						texture2D(uTexture, getModdedPos(center + vec2(stepSize, 0.0))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(-stepSize, 0.0))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(0.0, stepSize))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(0.0, -stepSize))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(stepSize, stepSize))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(stepSize, -stepSize))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(-stepSize, stepSize))).z
						+ texture2D(uTexture, getModdedPos(center + vec2(-stepSize, -stepSize))).z
					);
				}

				else
				{
					surroundingState = (
						texture2D(uTexture, center + vec2(stepSize, 0.0)).z
						+ texture2D(uTexture, center + vec2(-stepSize, 0.0)).z
						+ texture2D(uTexture, center + vec2(0.0, stepSize)).z
						+ texture2D(uTexture, center + vec2(0.0, -stepSize)).z
						+ texture2D(uTexture, center + vec2(stepSize, stepSize)).z
						+ texture2D(uTexture, center + vec2(stepSize, -stepSize)).z
						+ texture2D(uTexture, center + vec2(-stepSize, stepSize)).z
						+ texture2D(uTexture, center + vec2(-stepSize, -stepSize)).z
					);
				}

				if (state < 0.5)
				{
					if (surroundingState >= 2.5 && surroundingState <= 3.5)
					{
						// Becoming alive
						gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
						return;
					}
					
					// Staying dead
					gl_FragColor = vec4(max(thisPixel.x - glowChangeSpeed, 0.0), 0.0, 0.0, 1.0);
					return;
				}

				if (surroundingState <= 1.5 || surroundingState >= 3.5)
				{
					// Becoming dead
					gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
					return;
				}

				// Staying alive
				gl_FragColor = vec4(0.0, max(thisPixel.y - glowChangeSpeed, 0.0), 1.0, 1.0);
				return;
			}
		`},uniforms:{noUpdate:{stepSize:1/this.gridSize},update:{stepSize:1/this.gridSize,onTorus:this.onTorus?1:0}},canvasWidth:this.resolution},e=(this.wilsonHidden=new WilsonGPU(e,t),{shader:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;

			uniform vec2 worldCenter;
			uniform vec2 worldSize;

			const vec4 aliveColor = vec4(1.0, 1.0, 1.0, 1.0);
			const vec4 growingColor = vec4(0.5, 0.0, 1.0, 1.0);
			const vec4 dyingColor = vec4(0.0, 0.0, 1.0, 1.0);
			const vec4 deadColor = vec4(0.0, 0.0, 0.0, 1.0);
			
			void main(void)
			{
				vec2 xy = (uv * worldSize / 2.0 + worldCenter) + vec2(0.5, 0.5);

				if (max(xy.x, xy.y) >= 1.0 || min(xy.x, xy.y) <= 0.0)
				{
					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
					return;
				}

				gl_FragColor = texture2D(uTexture, xy);

				if (gl_FragColor.w == 0.0)
				{
					gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
					return;
				}

				// Convert red to blue and green to purple.
				if (gl_FragColor.z > 0.5)
				{
					gl_FragColor = mix(aliveColor, growingColor, gl_FragColor.y);
					return;
				}

				gl_FragColor = mix(deadColor, dyingColor, gl_FragColor.x);
				return;
			}
		`,uniforms:{worldCenter:[0,0],worldSize:[1.2,1.2]},canvasWidth:this.resolution,worldWidth:1.2,minWorldX:-.6,maxWorldX:.6,minWorldY:-.6,maxWorldY:.6,minWorldWidth:.05,minWorldHeight:.05,interactionOptions:{useForPanAndZoom:!0,onPanAndZoom:()=>this.needNewFrame=!0},fullscreenOptions:{onSwitch:this.switchFullscreen.bind(this),beforeSwitch:this.beforeSwitchFullscreen.bind(this),fillScreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}});this.wilson=new WilsonGPU(canvas,e)}run({resolution=1e3,gridSize=100,state,pauseUpdating=!0,onTorus=this.onTorus}){this.gridSize=gridSize,this.resolution=Math.max(resolution,2*this.gridSize),this.onTorus=onTorus,this.pauseUpdating=pauseUpdating,this.wilsonHidden.setUniforms({stepSize:1/this.gridSize},"noUpdate"),this.wilsonHidden.setUniforms({stepSize:1/this.gridSize,onTorus:this.onTorus?1:0},"update"),this.wilsonHidden.useShader(this.pauseUpdating?"noUpdate":"update"),this.wilsonHidden.resizeCanvas({width:this.gridSize}),this.wilson.resizeCanvas({width:this.resolution}),this.wilson.createFramebufferTexturePair({id:"draw",width:this.gridSize,height:this.gridSize,textureType:"unsignedByte"}),this.wilsonHidden.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilsonHidden.createFramebufferTexturePair({id:"1",textureType:"unsignedByte"}),this.wilsonHidden.useTexture("0"),this.wilsonHidden.useFramebuffer(null),this.wilsonHidden.setTexture({id:"1",data:null}),this.wilsonHidden.useTexture("0"),this.loadState(state),this.frame=0,this.currentFramebuffer="1",this.resume()}drawFrame(){this.frame%this.framesPerUpdate==0&&(this.frame=0,this.updateGame()),this.wilson.setUniforms({worldCenter:[this.wilson.worldCenterX,this.wilson.worldCenterY],worldSize:[this.wilson.worldWidth,this.wilson.worldHeight]}),this.wilson.drawFrame(),this.frame++,this.needNewFrame=!0}updateGame(){if(!this.animationPaused){for(let e=0;e<this.updatesPerFrame*!this.pauseUpdating;e++)this.wilsonHidden.useFramebuffer(this.currentFramebuffer),this.wilsonHidden.drawFrame(),this.wilsonHidden.useTexture(this.currentFramebuffer),this.currentFramebuffer="0"===this.currentFramebuffer?"1":"0";this.wilsonHidden.useFramebuffer(null),this.wilsonHidden.drawFrame(),this.wilson.setTexture({id:"draw",data:this.wilsonHidden.readPixels()}),this.wilson.useFramebuffer(null)}}resumeUpdating(){this.pauseUpdating=!1,this.wilsonHidden.useShader("update"),this.wilsonHidden.setUniforms({stepSize:1/this.gridSize},"update")}loadState(state){if(Math.sqrt(state.length)!==this.gridSize)console.error("Invalid state size!");else{var t=new Uint8Array(4*state.length);for(let e=0;e<state.length;e++)t[4*e]=0,t[4*e+1]=255*state[e],t[4*e+2]=255*state[e],t[4*e+3]=255*state[e];this.wilsonHidden.setTexture({id:"0",data:t}),this.wilsonHidden.setTexture({id:"1",data:t})}}switchFullscreen(){this.resume()}async beforeSwitchFullscreen(){this.animationPaused=!0,await new Promise(resolve=>setTimeout(resolve,33))}}export{GameOfLife};