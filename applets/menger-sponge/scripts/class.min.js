import{mat3TimesVector,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";const changeColorGlsl=`
	vec3 colorAdd = abs(pos / effectiveScale);
	color = normalize(color + colorAdd * colorScale);
	colorScale *= 0.5;
`;function getDistanceEstimatorGlsl(useForGetColor=!1){return`
		pos = abs(pos);
		float maxAbsPos = max(max(pos.x, pos.y), pos.z);
		float minAbsPos = min(min(pos.x, pos.y), pos.z);
		float sumAbsPos = pos.x + pos.y + pos.z;
		pos = vec3(minAbsPos, sumAbsPos - minAbsPos - maxAbsPos, maxAbsPos);

		${useForGetColor?"vec3 color = vec3(0.25); float colorScale = 0.5;":""}

		float totalDistance;
		vec3 totalScale = vec3(1.0, 1.0, 1.0);
		float effectiveScale;

		float invScale = 1.0 / scale;
		float cornerFactor = 2.0 * scale / (scale - 1.0);
		float edgeFactor = 2.0 * scale / (scale - 1.0);

		vec3 cornerScaleCenter = (cornerFactor - 1.0) * vec3(1.0);
		vec3 edgeScaleCenter = vec3(0.0, edgeFactor - 1.0, edgeFactor - 1.0);

		float cornerRadius = 0.5 * (1.0 - invScale);
		float cornerCenter = 0.5 * (1.0 + invScale);

		float edgeLongRadius = invScale;
		float edgeShortRadius = 0.5 * (1.0 - invScale);
		float edgeCenter = 0.5 * (1.0 + invScale);

		for (int iteration = 0; iteration < maxIterations; iteration++)
		{
			if (iteration == iterations)
			{
				break;
			}

			float distanceToCornerX = abs(pos.x - cornerCenter) - cornerRadius;
			float distanceToCornerY = abs(pos.y - cornerCenter) - cornerRadius;
			float distanceToCornerZ = abs(pos.z - cornerCenter) - cornerRadius;
			float distanceToCorner = max(distanceToCornerX, max(distanceToCornerY, distanceToCornerZ));
			
			float distanceToEdgeX = abs(pos.x) - edgeLongRadius;
			float distanceToEdgeY = abs(pos.y - edgeCenter) - edgeShortRadius;
			float distanceToEdgeZ = abs(pos.z - edgeCenter) - edgeShortRadius;
			float distanceToEdge = max(distanceToEdgeX, max(distanceToEdgeY, distanceToEdgeZ));

			if (distanceToCorner < distanceToEdge)
			{
				totalDistance = distanceToCorner;

				if (distanceToCornerX > max(distanceToCornerY, distanceToCornerZ))
				{
					effectiveScale = totalScale.x;
				}

				else if (distanceToCornerY > max(distanceToCornerX, distanceToCornerZ))
				{
					effectiveScale = totalScale.y;
				}

				else
				{
					effectiveScale = totalScale.z;
				}

				// Scale all directions by 2s/(s-1) from (1, 1, 1) * separation.
				pos = cornerFactor * pos - cornerScaleCenter;

				totalScale *= cornerFactor;
			}

			else
			{
				totalDistance = distanceToEdge;
				
				if (distanceToEdgeX > max(distanceToEdgeY, distanceToEdgeZ))
				{
					effectiveScale = totalScale.x;
				}

				else if (distanceToEdgeY > max(distanceToEdgeX, distanceToEdgeZ))
				{
					effectiveScale = totalScale.y;
				}

				else
				{
					effectiveScale = totalScale.z;
				}

				// Scale x by s and y and z by 2s/(s-1) from (0, 1, 1). The second term is equal to
				pos = vec3(1.0 / edgeLongRadius, edgeFactor, edgeFactor) * pos - edgeScaleCenter;

				totalScale *= vec3(1.0 / edgeLongRadius, edgeFactor, edgeFactor);
			}

			${useForGetColor?changeColorGlsl:""}

			pos = abs(pos);
			pos = rotationMatrix * pos;
			maxAbsPos = max(max(pos.x, pos.y), pos.z);
			minAbsPos = min(min(pos.x, pos.y), pos.z);
			sumAbsPos = pos.x + pos.y + pos.z;
			pos = vec3(minAbsPos, sumAbsPos - minAbsPos - maxAbsPos, maxAbsPos);
		}
		
		${useForGetColor?"return abs(color);":"return totalDistance / effectiveScale;"}
	`}class MengerSponge extends RaymarchApplet{rotationAngleX=0;rotationAngleY=0;rotationAngleZ=0;constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:getDistanceEstimatorGlsl(),getColorGlsl:getDistanceEstimatorGlsl(!0),addGlsl:`
			const int maxIterations = 16;
		`,uniformsGlsl:`
			uniform float scale;
			uniform int iterations;
			uniform mat3 rotationMatrix;
		`,uniforms:{scale:3,iterations:16,rotationMatrix:[[1,0,0],[0,1,0],[0,0,1]]},cameraPos:[3.5,0,0],theta:3*Math.PI/2,phi:Math.PI/2,stepFactor:.5,epsilonScaling:1.75,lightBrightness:1.75})}distanceEstimator(x,y,z){var e=this.uniforms.scale,a=this.uniforms.iterations;let o=[Math.abs(x),Math.abs(y),Math.abs(z)];var t=Math.max(Math.max(o[0],o[1]),o[2]),s=Math.min(Math.min(o[0],o[1]),o[2]),r=o[0]+o[1]+o[2];o=[s,r-s-t,t];let n;var c=[1,1,1];let i;var l=1/e,d=2*e/(e-1),m=2*e/(e-1),f=[d-1,d-1,d-1],p=[0,m-1,m-1],g=.5*(1-l),h=.5*(1+l),b=.5*(1-l),S=.5*(1+l);for(let F=0;F<a;F++){var v=Math.abs(o[0]-h)-g,M=Math.abs(o[1]-h)-g,u=Math.abs(o[2]-h)-g,C=Math.max(v,Math.max(M,u)),T=o[0]-l,A=Math.abs(o[1]-S)-b,E=Math.abs(o[2]-S)-b,P=Math.max(T,Math.max(A,E));C<P?(n=C,i=v>Math.max(M,u)?c[0]:M>Math.max(v,u)?c[1]:c[2],o=[d*o[0]-f[0],d*o[1]-f[1],d*o[2]-f[2]],c[0]*=d,c[1]*=d,c[2]*=d):(n=P,i=T>Math.max(A,E)?c[0]:A>Math.max(T,E)?c[1]:c[2],o=[e*o[0]-p[0],m*o[1]-p[1],m*o[2]-p[2]],c[0]*=e,c[1]*=m,c[2]*=m),o=[Math.abs(o[0]),Math.abs(o[1]),Math.abs(o[2])],o=mat3TimesVector(this.uniforms.rotationMatrix,o),t=Math.max(Math.max(o[0],o[1]),o[2]),s=Math.min(Math.min(o[0],o[1]),o[2]),r=o[0]+o[1]+o[2],o=[s,r-s-t,t]}return Math.abs(n)/i}}export{MengerSponge};