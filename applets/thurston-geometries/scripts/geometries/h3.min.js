import{getMinGlslString,getVectorGlsl}from"../../../../scripts/applets/applet.min.js";import{dotProduct,mat4TimesVector}from"../class.min.js";import{BaseGeometry}from"./base.min.js";const teleportVectors=[[1,0,0,1/Math.sqrt(3)],[-1,0,0,1/Math.sqrt(3)],[0,1,0,1/Math.sqrt(3)],[0,-1,0,1/Math.sqrt(3)],[0,0,1,1/Math.sqrt(3)],[0,0,-1,1/Math.sqrt(3)]];class H3Geometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = cosh(t) * startPos + sinh(t) * rayDirectionVec;

		globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;dotProductGlsl=`
		return v.x * w.x + v.y * w.y + v.z * w.z - v.w * w.w;
	`;normalizeGlsl=`
		return dir * inversesqrt(abs(geometryDot(dir, dir)));
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(0.5 - totalT * 0.075));
	`;getNormalVecGlsl=`
		return normalize(vec4(-pos.xyz, pos.w));
	`;correctPosGlsl=`
		pos = cosh(correctionDistance) * pos - sinh(correctionDistance) * surfaceNormal;
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}

		const vec4 teleportVec1 = ${getVectorGlsl(teleportVectors[0])};
		const vec4 teleportVec2 = ${getVectorGlsl(teleportVectors[1])};
		const vec4 teleportVec3 = ${getVectorGlsl(teleportVectors[2])};
		const vec4 teleportVec4 = ${getVectorGlsl(teleportVectors[3])};
		const vec4 teleportVec5 = ${getVectorGlsl(teleportVectors[4])};
		const vec4 teleportVec6 = ${getVectorGlsl(teleportVectors[5])};

		const mat4 teleportMat1 = mat4(
			2.0, 0.0, 0.0, 1.73205081,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			1.73205081, 0.0, 0.0, 2.0
		);
		
		const mat4 teleportMat2 = mat4(
			2.0, 0.0, 0.0, -1.73205081,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			-1.73205081, 0.0, 0.0, 2.0
		);
		
		const mat4 teleportMat3 = mat4(
			1.0, 0.0, 0.0, 0.0,
			0.0, 2.0, 0.0, 1.73205081,
			0.0, 0.0, 1.0, 0.0,
			0.0, 1.73205081, 0.0, 2.0
		);
		
		const mat4 teleportMat4 = mat4(
			1.0, 0.0, 0.0, 0.0,
			0.0, 2.0, 0.0, -1.73205081,
			0.0, 0.0, 1.0, 0.0,
			0.0, -1.73205081, 0.0, 2.0
		);
		
		const mat4 teleportMat5 = mat4(
			1.0, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 2.0, 1.73205081,
			0.0, 0.0, 1.73205081, 2.0
		);
		
		const mat4 teleportMat6 = mat4(
			1.0, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, 2.0, -1.73205081,
			0.0, 0.0, -1.73205081, 2.0
		);

		vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			if (dot(pos, teleportVec1) < 0.0)
			{
				pos = teleportMat1 * pos;

				// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
				// position, not the current one, so we need to calculate that current
				// position to teleport the vector correctly. The correct tangent vector
				// is just the derivative of the geodesic at the current value of t.

				rayDirectionVec = teleportMat1 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(1.0, 0.0, 0.0);
			}

			if (dot(pos, teleportVec2) < 0.0)
			{
				pos = teleportMat2 * pos;

				rayDirectionVec = teleportMat2 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(-1.0, 0.0, 0.0);
			}

			if (dot(pos, teleportVec3) < 0.0)
			{
				pos = teleportMat3 * pos;

				rayDirectionVec = teleportMat3 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 1.0, 0.0);
			}

			if (dot(pos, teleportVec4) < 0.0)
			{
				pos = teleportMat4 * pos;

				rayDirectionVec = teleportMat4 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, -1.0, 0.0);
			}

			if (dot(pos, teleportVec5) < 0.0)
			{
				pos = teleportMat5 * pos;

				rayDirectionVec = teleportMat5 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, 1.0);
			}

			if (dot(pos, teleportVec6) < 0.0)
			{
				pos = teleportMat6 * pos;

				rayDirectionVec = teleportMat6 * (sinh(t) * startPos + cosh(t) * rayDirectionVec);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, -1.0);
			}

			return vec3(0.0, 0.0, 0.0);
		}
	`;maxT="30.0";dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]-vec1[3]*vec2[3]}normalize(vec){var t=Math.sqrt(Math.abs(this.dotProduct(vec,vec)));return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}correctPosition(pos){return this.normalize(pos)}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],-cameraPos[2],cameraPos[3]])}correctVectors(){var t=this.dotProduct(this.cameraPos,this.upVec),e=this.dotProduct(this.cameraPos,this.rightVec),o=this.dotProduct(this.cameraPos,this.forwardVec);for(let s=0;s<4;s++)this.upVec[s]+=t*this.cameraPos[s],this.rightVec[s]+=e*this.cameraPos[s],this.forwardVec[s]+=o*this.cameraPos[s];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}baseColorIncreases=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(rotatedForwardVec,recomputeRotation){var t=[[[2,0,0,Math.sqrt(3)],[0,1,0,0],[0,0,1,0],[Math.sqrt(3),0,0,2]],[[2,0,0,-Math.sqrt(3)],[0,1,0,0],[0,0,1,0],[-Math.sqrt(3),0,0,2]],[[1,0,0,0],[0,2,0,Math.sqrt(3)],[0,0,1,0],[0,Math.sqrt(3),0,2]],[[1,0,0,0],[0,2,0,-Math.sqrt(3)],[0,0,1,0],[0,-Math.sqrt(3),0,2]],[[1,0,0,0],[0,1,0,0],[0,0,2,Math.sqrt(3)],[0,0,Math.sqrt(3),2]],[[1,0,0,0],[0,1,0,0],[0,0,2,-Math.sqrt(3)],[0,0,-Math.sqrt(3),2]]];for(let e=0;e<t.length;e++)dotProduct(this.cameraPos,teleportVectors[e])<0&&(this.cameraPos=mat4TimesVector(t[e],this.cameraPos),this.forwardVec=mat4TimesVector(t[e],this.forwardVec),this.rightVec=mat4TimesVector(t[e],this.rightVec),this.upVec=mat4TimesVector(t[e],this.upVec),recomputeRotation(mat4TimesVector(t[e],rotatedForwardVec)),this.baseColor[0]+=this.baseColorIncreases[e][0],this.baseColor[1]+=this.baseColorIncreases[e][1],this.baseColor[2]+=this.baseColorIncreases[e][2])}}const axesDistances=`
	float distance1 = acosh(sqrt(pos.w * pos.w - pos.x * pos.x)) - .05;
	float distance2 = acosh(sqrt(pos.w * pos.w - pos.y * pos.y)) - .05;
	float distance3 = acosh(sqrt(pos.w * pos.w - pos.z * pos.z)) - .05;

	float minDistance = ${getMinGlslString("distance",3)};
`;class H3Axes extends H3Geometry{geodesicGlsl=`
		vec4 pos = cosh(t) * startPos + sinh(t) * rayDirectionVec;
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}
	`;teleportCamera(){}distanceEstimatorGlsl=`
		${axesDistances}

		return minDistance;
	`;getColorGlsl=`
		${axesDistances}
		
		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(10.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(10.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(10.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(10.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(10.0 * pos.z) + 1.0)),
			.5 + .25 * (.5 * (cos(10.0 * pos.z) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(1.0, 1.0, 1.0, 0.0) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-1.0, -1.0, -1.0, 0.0) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity = max(
			max(abs(dotProduct1), abs(dotProduct2)),
			max(abs(dotProduct3), abs(dotProduct4))
		);
	`;cameraPos=[.89424,-.89424,.24177,1.63027];normalVec=[-.89424,.89424,-.24177,1.63027];upVec=[.07548,-.07548,1.02152,.23431];rightVec=[.7071,.7071,0,0];forwardVec=[-1.13752,1.13752,-.12226,-1.26605];movingSpeed=1}const roomsDistances=`
	float distance1 = maxT * 2.0;
	float distance2 = maxT * 2.0;

	if (sceneTransition < 1.0)
	{
		float scale = exp(max(sceneTransition - 0.8, 0.0) * 5.0);

		float effectiveWallThickness = wallThickness + sceneTransition * 4.0 / .75;

		distance1 = effectiveWallThickness - acosh(pos.w);
	}

	if (sceneTransition > 0.0)
	{
		float scale = exp(max(0.2 - sceneTransition, 0.0) * 5.0);

		float effectiveRadius = .425 - .425 / .75 * (1.0 - sceneTransition);

		distance2 = acosh(pos.w) - effectiveRadius;
	}

	if (totalT < clipDistance)
	{
		distance1 = maxT * 2.0;
		distance2 = maxT * 2.0;
	}

	// Translate the reflection plane to the x = 0 plane, then get the distance to it.
	// The DE to x = 0 is abs(asinh(pos.x)).
	float distance3 = abs(asinh(
		dot(
			vec4(1.23188, 0.0, 0.0, 0.71939),
			pos
		)
	));
	
	float distance4 = abs(asinh(
		dot(
			vec4(1.23188, 0.0, 0.0, -0.71939),
			pos
		)
	));

	float distance5 = abs(asinh(
		dot(
			vec4(0.0, 1.23188, 0.0, 0.71939),
			pos
		)
	));
	
	float distance6 = abs(asinh(
		dot(
			vec4(0.0, -1.23188, 0.0, 0.71939),
			pos
		)
	));

	float distance7 = abs(asinh(
		dot(
			vec4(0.0, 0.0, 1.23188, 0.71939),
			pos
		)
	));
	
	float distance8 = abs(asinh(
		dot(
			vec4(0.0, 0.0, -1.23188, 0.71939),
			pos
		)
	));

	float minDistance = ${getMinGlslString("distance",8)};
`;class H3Rooms extends H3Geometry{distanceEstimatorGlsl=`
		${roomsDistances}

		return minDistance;
	`;getColorGlsl=`
		vec3 roomColor = globalColor + baseColor;

		return mix(
			vec3(
				.25 + .75 * (.5 * (sin((.004 * pos.x + roomColor.x) * 40.0) + 1.0)),
				.25 + .75 * (.5 * (sin((.004 * pos.y + roomColor.y) * 57.0) + 1.0)),
				.25 + .75 * (.5 * (sin((.004 * pos.z + roomColor.z) * 89.0) + 1.0))
			),
			vec3(
				.15 + .85 * (.5 * (sin(floor(roomColor.x + .5) * .25) + 1.0)),
				.15 + .85 * (.5 * (sin(floor(roomColor.y + .5) * .25) + 1.0)),
				.15 + .85 * (.5 * (sin(floor(roomColor.z + .5) * .25) + 1.0))
			),
			sceneTransition
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 0.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, 0.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = mix(1.0, 1.25, sceneTransition) * max(abs(dotProduct1), abs(dotProduct2));
	`;cameraPos=[-.1,0,0,Math.sqrt(1.01)];normalVec=[.1,0,0,Math.sqrt(1.01)];upVec=[0,0,1,0];rightVec=[0,-1,0,0];forwardVec=[-1,0,0,0];movingSpeed=1.25;uniformGlsl=`
		uniform float sceneTransition;
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["sceneTransition","wallThickness","baseColor"];getUpdatedUniforms(){return{sceneTransition:this.sliderValues.sceneTransition,wallThickness:1.5-(this.sliderValues.wallThickness- -.357)/.5*.5,clipDistance:this.sliderValues.clipDistance,baseColor:this.baseColor}}uiElementsUsed="#wall-thickness-slider, #switch-scene-button, #clip-distance-slider";wallThicknessData=[.143,-.357,.143];maxClipDistance=6;doClipBrightening=!0;getNearestCenter(){return[0,0,0,1]}getNearestCorner(){var t=[[1,1,1,2],[1,-1,1,2],[-1,1,1,2],[-1,-1,1,2],[1,1,-1,2],[1,-1,-1,2],[-1,1,-1,2],[-1,-1,-1,2]];let e=1/0,o=0;for(let r=0;r<t.length;r++){var s=Math.acosh(this.cameraPos[0]*t[r][0]+this.cameraPos[1]*t[r][1]+this.cameraPos[2]*t[r][2]+this.cameraPos[3]*t[r][3]);s<e&&(e=s,o=r)}return t[o]}}export{H3Axes,H3Rooms};