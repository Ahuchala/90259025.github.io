import{getColorGlslString,getMaxGlslString,getMinGlslString}from"../../../../scripts/applets/applet.min.js";import{dotProduct,normalize}from"../class.min.js";import{BaseGeometry}from"./base.min.js";class S3Geometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = cos(t) * startPos + sin(t) * rayDirectionVec;
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-acos(dot(pos, cameraPos)) * fogScaling));
	`;getNormalVecGlsl=`
		return normalize(-pos);
	`;correctPosGlsl=`
		pos = cos(correctionDistance) * pos - sin(correctionDistance) * surfaceNormal;
	`;maxMarches="100";maxT="6.283";correctPosition(pos){return this.normalize(pos)}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],-cameraPos[2],-cameraPos[3]])}}const axesDistances=`
	float distance1 = acos(length(pos.xw)) - .05;
	float distance2 = acos(length(pos.yw)) - .05;
	float distance3 = acos(length(pos.zw)) - .05;

	float minDistance = ${getMinGlslString("distance",3)};
`;class S3Axes extends S3Geometry{distanceEstimatorGlsl=`
		${axesDistances}

		return minDistance;
	`;getColorGlsl=`
		${axesDistances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(20.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(20.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(20.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(20.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(20.0 * pos.z) + 1.0)),
			.5 + .25 * (.5 * (cos(20.0 * pos.z) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(.5, .5, .5, .5) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-.5, -.5, -.5, -.5) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.5 * min(abs(dotProduct1), abs(dotProduct2));
	`;cameraPos=[.6247,.6247,.4683,-.0157];normalVec=[-.6247,-.6247,-.4683,.0157];upVec=[-.3268,-.3268,.8657,-.1925];rightVec=[.7071,-.7071,0,0];forwardVec=[-.0542,-.0542,.1773,.9812]}const roomsDistances=`
	float minRoomDistance = 1000000.0;
	float minSphereDistance = 1000000.0;

	float acosX = acos(pos.x);
	float acosNegX = pi - acosX;
	float acosY = acos(pos.y);
	float acosNegY = pi - acosY;
	float acosZ = acos(pos.z);
	float acosNegZ = pi - acosZ;
	float acosW = acos(pos.w);
	float acosNegW = pi - acosW;

	float roomDistance1 = maxT * 2.0;
	float roomDistance2 = maxT * 2.0;
	float roomDistance3 = maxT * 2.0;
	float roomDistance4 = maxT * 2.0;
	float roomDistance5 = maxT * 2.0;
	float roomDistance6 = maxT * 2.0;
	float roomDistance7 = maxT * 2.0;
	float roomDistance8 = maxT * 2.0;

	if (sceneTransition < 1.0)
	{
		float scale = exp(max(sceneTransition - 0.8, 0.0) * 5.0);

		float effectiveWallThickness = wallThickness + sceneTransition * .125 / .75;
		roomDistance1 = effectiveWallThickness - acosX;
		roomDistance2 = effectiveWallThickness - acosNegX;
		roomDistance3 = effectiveWallThickness - acosY;
		roomDistance4 = effectiveWallThickness - acosNegY;
		roomDistance5 = effectiveWallThickness - acosZ;
		roomDistance6 = effectiveWallThickness - acosNegZ;
		roomDistance7 = effectiveWallThickness - acosW;
		roomDistance8 = effectiveWallThickness - acosNegW;

		minRoomDistance = ${getMaxGlslString("roomDistance",8)} * scale;
	}

	float sphereDistance1 = maxT * 2.0;
	float sphereDistance2 = maxT * 2.0;
	float sphereDistance3 = maxT * 2.0;
	float sphereDistance4 = maxT * 2.0;
	float sphereDistance5 = maxT * 2.0;
	float sphereDistance6 = maxT * 2.0;
	float sphereDistance7 = maxT * 2.0;

	if (sceneTransition > 0.0)
	{
		float scale = exp(max(0.2 - sceneTransition, 0.0) * 5.0);

		float effectiveRadius = .3 - .3 / .75 * (1.0 - sceneTransition);
		sphereDistance1 = acosX - effectiveRadius;
		sphereDistance2 = acosNegX - effectiveRadius;
		sphereDistance3 = acosY - effectiveRadius;
		sphereDistance4 = acosNegY - effectiveRadius;
		sphereDistance5 = acosZ - effectiveRadius;
		sphereDistance6 = acosNegZ - effectiveRadius;
		sphereDistance7 = acosW - effectiveRadius;

		minSphereDistance = ${getMinGlslString("sphereDistance",7)} * scale;
	}
	
	float minDistance = min(minRoomDistance, minSphereDistance);
`;class S3Rooms extends S3Geometry{distanceEstimatorGlsl=`
		${roomsDistances}

		return minDistance;
	`;getColorGlsl=`
		${roomsDistances}

		float roomVariation = .075;
		float sphereVariation = .25;

		if (minDistance == roomDistance1)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((roomVariation * pos.y) * 17.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance2)
		{
			return vec3(
				.5 * (.5 * (sin((roomVariation * pos.y) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.z) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance3)
		{
			return vec3(
				.5 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance4)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((roomVariation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance5)
		{
			return vec3(
				.5 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance6)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance7)
		{
			return vec3(
				.5 + .15 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((roomVariation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((roomVariation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance8)
		{
			return vec3(
				.65 + .35 * (.5 * (sin((roomVariation * pos.x) * 17.0) + 1.0)),
				.65 + .35 * (.5 * (sin((roomVariation * pos.y) * 23.0) + 1.0)),
				.65 + .35 * (.5 * (sin((roomVariation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == sphereDistance1)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((sphereVariation * pos.y) * 17.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance2)
		{
			return vec3(
				.5 * (.5 * (sin((sphereVariation * pos.y) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((sphereVariation * pos.z) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((sphereVariation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance3)
		{
			return vec3(
				.5 * (.5 * (sin((sphereVariation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((sphereVariation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance4)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((sphereVariation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((sphereVariation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.z) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance5)
		{
			return vec3(
				.5 * (.5 * (sin((sphereVariation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((sphereVariation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance6)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((sphereVariation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((sphereVariation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((sphereVariation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		return vec3(
			.5 + .15 * (.5 * (sin((sphereVariation * pos.x) * 17.0) + 1.0)),
			.5 * (.5 * (sin((sphereVariation * pos.y) * 23.0) + 1.0)),
			.85 + .15 * (.5 * (sin((sphereVariation * pos.z) * 29.0) + 1.0))
		) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, -1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity1 = 4.0 * max(dotProduct1, dotProduct2);



		vec4 lightDirection3 = normalize(vec4(.5, .5, .5, .5) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-.5, -.5, -.5, -.5) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity2 = 1.75 * min(abs(dotProduct3), abs(dotProduct4));



		float lightIntensity = mix(lightIntensity1, lightIntensity2, sceneTransition);
	`;cameraPos=[0,-.20927,0,-.97785];normalVec=[-0,.20934,-0,.97784];upVec=[0,0,1,0];rightVec=[1,0,0,0];forwardVec=[0,-.97784,0,.20934];uniformGlsl=`
		uniform float sceneTransition;
		uniform float wallThickness;
	`;uniformNames=["sceneTransition","wallThickness"];getUpdatedUniforms(){return{wallThickness:.97-(this.sliderValues.wallThickness- -.15)/.5*(.97-.92),sceneTransition:this.sliderValues.sceneTransition}}uiElementsUsed="#wall-thickness-slider, #switch-scene-button";wallThicknessData=[.35,-.15,.35];getNearestCenter(){var o=[[1,0,0,0],[-1,0,0,0],[0,1,0,0],[0,-1,0,0],[0,0,1,0],[0,0,-1,0],[0,0,0,1],[0,0,0,-1]];let s=Math.PI,e=0;for(let i=0;i<o.length;i++){var t=Math.acos(dotProduct(o[i],this.cameraPos));t<s&&(s=t,e=i)}return o[e]}getNearestCorner(){var o=[[.5,.5,.5,.5],[.5,.5,.5,-.5],[.5,.5,-.5,.5],[.5,.5,-.5,-.5],[.5,-.5,.5,.5],[.5,-.5,.5,-.5],[.5,-.5,-.5,.5],[.5,-.5,-.5,-.5],[-.5,.5,.5,.5],[-.5,.5,.5,-.5],[-.5,.5,-.5,.5],[-.5,.5,-.5,-.5],[-.5,-.5,.5,.5],[-.5,-.5,.5,-.5],[-.5,-.5,-.5,.5],[-.5,-.5,-.5,-.5]];let s=Math.PI,e=0;for(let i=0;i<o.length;i++){var t=Math.acos(dotProduct(o[i],this.cameraPos));t<s&&(s=t,e=i)}return o[e]}}function hsvToRgb(h,s,v){function o(n){var o=(n+6*h)%6;return v-v*s*Math.max(0,Math.min(o,Math.min(4-o,1)))}return[255*o(5),255*o(3),255*o(1)]}function getHopfFiber(index,numFibers,theta,startingFiber){var o=index/numFibers*(2*Math.PI),s=hsvToRgb(theta/Math.PI,Math.abs(o%Math.PI-Math.PI/2)/(Math.PI/2),1),o=[Math.cos(o)*Math.sin(theta),Math.sin(o)*Math.sin(theta),Math.cos(theta)],e=normalize([1+o[2],-o[1],o[0],0]),o=normalize([0,o[0],o[1],1+o[2]]);return[`
		float distance${index+1+startingFiber} = greatCircleDistance(
			pos,
			vec4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]}),
			vec4(${o[0]}, ${o[1]}, ${o[2]}, ${o[3]}),
			fiberThickness);
		`,s]}class S3HopfFibration extends S3Geometry{constructor(){super();var o=18,s=(this.distanceEstimatorGlsl="",new Array(56));for(let i=0;i<o;i++){const e=getHopfFiber(i,o,Math.PI/4,0);this.distanceEstimatorGlsl+=e[0],s[i]=e[1]}for(let a=0;a<o;a++){const e=getHopfFiber(a,o,Math.PI/2,o);this.distanceEstimatorGlsl+=e[0],s[o+a]=e[1]}for(let n=0;n<o;n++){const e=getHopfFiber(n,o,3*Math.PI/4,36);this.distanceEstimatorGlsl+=e[0],s[36+n]=e[1]}const e=getHopfFiber(0,1,0,54);this.distanceEstimatorGlsl+=e[0],s[54]=[255,255,96];var t=getHopfFiber(0,1,Math.PI,55);this.distanceEstimatorGlsl+=t[0],s[55]=[255,96,96],this.distanceEstimatorGlsl+=`
			float minDistance = ${getMinGlslString("distance",56)};
		`,this.getColorGlsl=this.distanceEstimatorGlsl+getColorGlslString("distance","minDistance",s),this.distanceEstimatorGlsl+="return minDistance;"}functionGlsl=`
		//p and v must be orthonormal.
		float greatCircleDistance(vec4 pos, vec4 p, vec4 v, float r)
		{
			float dot1 = dot(pos, p);
			float dot2 = dot(pos, v);

			return acos(sqrt(dot1 * dot1 + dot2 * dot2)) - r;
		}
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(1.0, 1.0, 1.0, 0.0) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-1.0, -1.0, -1.0, 0.0) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity = max(
			max(abs(dotProduct1), abs(dotProduct2)),
			max(abs(dotProduct3), abs(dotProduct4))
		);
	`;cameraPos=[-.0403,.4848,-.0054,-.8736];normalVec=[.0403,-.4848,.0054,.8736];upVec=[-2e-4,.0021,.9999,-.005];rightVec=[-.9987,.0057,-0,.0493];forwardVec=[.0289,.8745,6e-4,.4839];uniformGlsl=`
		uniform float fiberThickness;
	`;uniformNames=["fiberThickness"];getUpdatedUniforms(){return{fiberThickness:this.sliderValues.fiberThickness}}}export{S3Axes,S3Rooms,S3HopfFibration};