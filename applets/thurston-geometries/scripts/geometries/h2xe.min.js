import{getMatrixGlsl,getMinGlslString,getVectorGlsl}from"../../../../scripts/applets/applet.min.js";import{dotProduct,mat4TimesVector}from"../class.min.js";import{BaseGeometry}from"./base.min.js";const teleportations=[[[1,0,1/Math.sqrt(3),0],[[2,0,Math.sqrt(3),0],[0,1,0,0],[Math.sqrt(3),0,2,0],[0,0,0,1]]],[[-1,0,1/Math.sqrt(3),0],[[2,0,-Math.sqrt(3),0],[0,1,0,0],[-Math.sqrt(3),0,2,0],[0,0,0,1]]],[[0,1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,Math.sqrt(3),0],[0,Math.sqrt(3),2,0],[0,0,0,1]]],[[0,-1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,-Math.sqrt(3),0],[0,-Math.sqrt(3),2,0],[0,0,0,1]]]];class H2xEGeometry extends BaseGeometry{geodesicGlsl=`
		float h2Mag = sqrt(abs(
			rayDirectionVec.x * rayDirectionVec.x
			+ rayDirectionVec.y * rayDirectionVec.y
			- rayDirectionVec.z * rayDirectionVec.z
		));
		
		vec4 pos = vec4(
			cosh(h2Mag * t)
				* startPos.xyz
			+ sinh(h2Mag * t)
				* rayDirectionVec.xyz / h2Mag,
			startPos.w + t * rayDirectionVec.w
		);
		
		globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;dotProductGlsl=`
		return v.x * w.x + v.y * w.y - v.z * w.z + v.w * w.w;
	`;normalizeGlsl=`
		return dir * inversesqrt(abs(geometryDot(dir, dir)));
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * 0.25));
	`;getNormalVecGlsl=`
		return normalize(vec4(-pos.xy, pos.z, 0.0));
	`;correctPosGlsl=`
		float h2Mag = sqrt(abs(
			surfaceNormal.x * surfaceNormal.x
			+ surfaceNormal.y * surfaceNormal.y
			- surfaceNormal.z * surfaceNormal.z
		));
		
		pos = vec4(
			cosh(h2Mag * correctionDistance)
				* pos.xyz
			- sinh(h2Mag * correctionDistance)
				* surfaceNormal.xyz / h2Mag,
			pos.w - correctionDistance * surfaceNormal.w
		);
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}

		const vec4 teleportVec1 = ${getVectorGlsl(teleportations[0][0])};
		const mat4 teleportMat1 = ${getMatrixGlsl(teleportations[0][1])};

		const vec4 teleportVec2 = ${getVectorGlsl(teleportations[1][0])};
		const mat4 teleportMat2 = ${getMatrixGlsl(teleportations[1][1])};

		const vec4 teleportVec3 = ${getVectorGlsl(teleportations[2][0])};
		const mat4 teleportMat3 = ${getMatrixGlsl(teleportations[2][1])};

		const vec4 teleportVec4 = ${getVectorGlsl(teleportations[3][0])};
		const mat4 teleportMat4 = ${getMatrixGlsl(teleportations[3][1])};

		vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			if (dot(pos, teleportVec1) < 0.0)
			{
				pos = teleportMat1 * pos;

				// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
				// position, not the current one, so we need to calculate that current
				// position to teleport the vector correctly. The correct tangent vector
				// is just the derivative of the geodesic at the current value of t.

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));

				rayDirectionVec = teleportMat1 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 1.0, 0.0);
			}

			if (dot(pos, teleportVec2) < 0.0)
			{
				pos = teleportMat2 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat2 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, -1.0, 0.0);
			}

			if (dot(pos, teleportVec3) < 0.0)
			{
				pos = teleportMat3 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat3 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, 1.0);
			}

			if (dot(pos, teleportVec4) < 0.0)
			{
				pos = teleportMat4 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat4 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, -1.0);
			}

			return vec3(0.0, 0.0, 0.0);
		}
	`;maxT="30.0";correctPosition(pos){var t=Math.sqrt(-pos[0]*pos[0]-pos[1]*pos[1]+pos[2]*pos[2]);return[pos[0]/t,pos[1]/t,pos[2]/t,pos[3]]}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],cameraPos[2],0])}dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]+vec1[3]*vec2[3]}normalize(vec){var t=Math.sqrt(Math.abs(this.dotProduct(vec,vec)));return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}correctVectors(){function t(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]}var e=t(this.cameraPos,this.upVec),o=t(this.cameraPos,this.rightVec),r=t(this.cameraPos,this.forwardVec);for(let s=0;s<3;s++)this.upVec[s]+=e*this.cameraPos[s],this.rightVec[s]+=o*this.cameraPos[s],this.forwardVec[s]+=r*this.cameraPos[s];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}baseColorIncreases=[[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(rotatedForwardVec,recomputeRotation){for(let t=0;t<teleportations.length;t++)dotProduct(this.cameraPos,teleportations[t][0])<0&&(this.cameraPos=mat4TimesVector(teleportations[t][1],this.cameraPos),this.forwardVec=mat4TimesVector(teleportations[t][1],this.forwardVec),this.rightVec=mat4TimesVector(teleportations[t][1],this.rightVec),this.upVec=mat4TimesVector(teleportations[t][1],this.upVec),recomputeRotation(mat4TimesVector(teleportations[t][1],rotatedForwardVec)),this.baseColor[0]+=this.baseColorIncreases[t][0],this.baseColor[1]+=this.baseColorIncreases[t][1],this.baseColor[2]+=this.baseColorIncreases[t][2])}}const axesDistances=`
	float distance1 = length(vec2(acosh(sqrt(1.0 + pos.y * pos.y)), pos.w)) - .05;
	float distance2 = length(vec2(acosh(sqrt(1.0 + pos.x * pos.x)), pos.w)) - .05;
	float distance3 = acosh(pos.z) - .05;

	float minDistance = ${getMinGlslString("distance",3)};
`;class H2xEAxes extends H2xEGeometry{geodesicGlsl=`
		float h2Mag = sqrt(abs(
			rayDirectionVec.x * rayDirectionVec.x
			+ rayDirectionVec.y * rayDirectionVec.y
			- rayDirectionVec.z * rayDirectionVec.z
		));
		
		vec4 pos = vec4(
			cosh(h2Mag * t) * startPos.xyz + sinh(h2Mag * t) * rayDirectionVec.xyz / h2Mag,
			startPos.w + t * rayDirectionVec.w
		);
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}
	`;teleportCamera(){}distanceEstimatorGlsl=`
		${axesDistances}

		return minDistance;
	`;getColorGlsl=`
		${axesDistances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(20.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(20.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(20.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(20.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(5.0 * pos.w) + 1.0)),
			.5 + .25 * (.5 * (cos(5.0 * pos.w) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - pos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.5 * dotProduct1;
	`;cameraPos=[-.52612,.55674,1.25967,.34129];normalVec=[.52619,-.55667,1.25966,0];upVec=[0,0,0,1];rightVec=[.70684,.70758,.01743,0];forwardVec=[.88161,-.89956,-.7658,0];movingSpeed=1.25}const roomsDistances=`
	float spacing = 1.875;

	float distance1 = maxT * 2.0;
	float distance2 = maxT * 2.0;

	if (sceneTransition < 1.0)
	{
		float scale = exp(max(sceneTransition - 0.8, 0.0) * 5.0);

		float effectiveWallThickness = wallThickness + sceneTransition * .48 / .75;

		distance1 = effectiveWallThickness - length(vec2(acosh(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
	}

	if (sceneTransition > 0.0)
	{
		float scale = exp(max(0.2 - sceneTransition, 0.0) * 5.0);

		float effectiveRadius = .4 - .4 / .75 * (1.0 - sceneTransition);

		distance2 = (length(vec2(acosh(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0)) - effectiveRadius) * scale;
	}

	if (totalT < clipDistance)
	{
		distance1 = maxT * 2.0;
		distance2 = maxT * 2.0;
	}
	

	// Translate the reflection plane to the x = 0 plane, then get the distance to it.
	// The DE to x = 0 is abs(asinh(pos.x)).
	float distance3 = abs(asinh(
		dot(
			vec4(1.23188, 0.0, 0.71939, 0),
			pos
		)
	));
	
	float distance4 = abs(asinh(
		dot(
			vec4(1.23188, 0.0, -0.71939, 0),
			pos
		)
	));

	float distance5 = abs(asinh(
		dot(
			vec4(0.0, 1.23188, 0.71939, 0),
			pos
		)
	));
	
	float distance6 = abs(asinh(
		dot(
			vec4(0.0, -1.23188, 0.71939, 0),
			pos
		)
	));

	float minDistance = ${getMinGlslString("distance",6)};
`;class H2xERooms extends H2xEGeometry{distanceEstimatorGlsl=`
		${roomsDistances}

		return minDistance;
	`;getColorGlsl=`
		${roomsDistances}

		vec3 roomColor = globalColor + baseColor;

		float wColor = floor((pos.w + 3.0 * spacing / 2.0) / spacing) - spacing / 2.0;

		return mix(
			vec3(
				.15 + .85 * .5 * (sin((.05 * pos.x + wColor + roomColor.y + roomColor.z) * 5.0) + 1.0),
				.15 + .85 * .5 * (sin((.05 * pos.y + wColor + roomColor.y) * 7.0) + 1.0),
				.15 + .85 * .5 * (sin((.05 * pos.z + wColor + roomColor.z) * 11.0) + 1.0)
			),
			vec3(
				.15 + .85 * (.5 * (sin(floor(wColor + roomColor.x + .5) * .25) + 1.0)),
				.15 + .85 * (.5 * (sin(floor(wColor + roomColor.y + .5) * .25) + 1.0)),
				.15 + .85 * (.5 * (sin(floor(wColor + roomColor.z + .5) * .25) + 1.0))
			),
			sceneTransition
		);
	`;lightGlsl=`
		float spacing = 1.875;
		vec4 moddedPos = vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0);

		if (sceneTransition == 1.0)
		{
			moddedPos.xyz *= 1.001;
			surfaceNormal = getSurfaceNormal(moddedPos, totalT);
		}

		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - moddedPos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		vec4 lightDirection2 = normalize(vec4(1.0, -1.0, 0.0, -.5) - moddedPos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		

		float lightIntensity = mix(1.5, 2.0, sceneTransition) * max(dotProduct1, dotProduct2);
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * mix(0.25, 0.05, sceneTransition)));
	`;cameraPos=[0,.025,Math.sqrt(1.000625),0];normalVec=[0,-.025,Math.sqrt(1.000625),0];upVec=[0,0,0,1];rightVec=[-1,0,0,0];forwardVec=[0,1,0,0];movingSpeed=1.25;uniformGlsl=`
		uniform float sceneTransition;
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["sceneTransition","wallThickness","baseColor"];getUpdatedUniforms(){return{sceneTransition:this.sliderValues.sceneTransition,wallThickness:1.145-this.sliderValues.wallThickness/10,clipDistance:this.sliderValues.clipDistance,baseColor:this.baseColor}}uiElementsUsed="#wall-thickness-slider, #switch-scene-button, #clip-distance-slider";wallThicknessData=[1.55,-.55,1.55];maxClipDistance=5;doClipBrightening=!0;getNearestCenter(){return[0,0,1,1.875*Math.round(this.cameraPos[3]/1.875)]}getNearestCorner(){var t=1.875,e=(this.cameraPos[3]+t/2)%t-t/2,o=[[1,1,Math.sqrt(3),t/2],[1,-1,Math.sqrt(3),t/2],[-1,1,Math.sqrt(3),t/2],[-1,-1,Math.sqrt(3),t/2],[1,1,Math.sqrt(3),-t/2],[1,-1,Math.sqrt(3),-t/2],[-1,1,Math.sqrt(3),-t/2],[-1,-1,Math.sqrt(3),-t/2]];let r=1/0,s=0;for(let i=0;i<o.length;i++){var a=Math.acosh(this.cameraPos[0]*o[i][0]+this.cameraPos[1]*o[i][1]+this.cameraPos[2]*o[i][2]),c=e-o[i][3],a=a*a+c*c;a<r&&(r=a,s=i)}return[o[s][0],o[s][1],o[s][2],this.cameraPos[3]-e+o[s][3]]}}export{H2xEAxes,H2xERooms};