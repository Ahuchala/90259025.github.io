import{getMinGlslString}from"../../../../scripts/applets/applet.min.js";import{magnitude}from"../class.min.js";import{BaseGeometry}from"./base.min.js";class E3Geometry extends BaseGeometry{}const axesDistances=`
	float distance1 = length(pos.yz) - .25;
	float distance2 = length(pos.xz) - .25;
	float distance3 = length(pos.xy) - .25;

	float minDistance = ${getMinGlslString("distance",3)};
`;class E3Axes extends E3Geometry{distanceEstimatorGlsl=`
		${axesDistances}

		return minDistance;
	`;getColorGlsl=`
		${axesDistances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(pos.z) + 1.0)),
			.5 + .25 * (.5 * (cos(pos.z) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(10.0, 10.0, 10.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.25 + .75 * dotProduct1 * dotProduct1) * 1.5;
	`;cameraPos=[4,4,2,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[Math.sqrt(2)/2,-Math.sqrt(2)/2,0,0];forwardVec=[-Math.sqrt(2)/2,-Math.sqrt(2)/2,0,0];movingSpeed=4}const roomsDistances=`
	float roomDistance = 1000000.0;
	float sphereDistance = 1000000.0;

	if (sceneTransition < 1.0)
	{
		float scale = exp(max(sceneTransition - 0.8, 0.0) * 5.0);

		float effectiveWallThickness = wallThickness + sceneTransition * .471 / .75;

		roomDistance = (effectiveWallThickness - length(mod(pos.xyz, 2.0) - vec3(1.0, 1.0, 1.0))) * scale;
	}

	if (sceneTransition > 0.0)
	{
		float scale = exp(max(0.2 - sceneTransition, 0.0) * 5.0);

		float effectiveRadius = .49 - .49 / .75 * (1.0 - sceneTransition);

		sphereDistance = (length(mod(pos.xyz, 2.0) - vec3(1.0, 1.0, 1.0)) - effectiveRadius) * scale;
	}
	
	float minDistance = max(
		min(roomDistance, sphereDistance),
		clipDistance - length(pos.xyz - cameraPos.xyz)
	);
`;class E3Rooms extends E3Geometry{distanceEstimatorGlsl=`
		${roomsDistances}

		return minDistance;
	`;getColorGlsl=`
		return mix(
			vec3(
				.25 + .75 * (.5 * (sin(pos.z * 0.75) + 1.0)),
				.25 + .75 * (.5 * (sin(pos.x * 0.75) + 1.0)),
				.25 + .75 * (.5 * (sin((-pos.y + 2.0) * 0.75) + 1.0))
			),
			vec3(
				.25 + .75 * (.5 * (sin(floor(pos.x + .5) * 40.0) + 1.0)),
				.25 + .75 * (.5 * (sin(floor(pos.y + .5) * 57.0) + 1.0)),
				.25 + .75 * (.5 * (sin(floor(pos.z + .5) * 89.0) + 1.0))
			),
			sceneTransition
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity1 = (.25 + .75 * dotProduct1 * dotProduct1) * 1.5;

		vec4 lightDirection2 = normalize(vec4(1.5, -1.5, 0.5, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity2 = max(dotProduct2, -.5 * dotProduct2) * 1.25;

		float lightIntensity = mix(lightIntensity1, lightIntensity2, sceneTransition);
	`;cameraPos=[1,1.25,1,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[-1,0,0,0];forwardVec=[0,1,0,0];movingSpeed=2;uniformGlsl=`
		uniform float sceneTransition;
		uniform float wallThickness;
	`;uniformNames=["sceneTransition","wallThickness"];getUpdatedUniforms(){return{sceneTransition:this.sliderValues.sceneTransition,wallThickness:1.5-(this.sliderValues.wallThickness+.85)/2*.2,clipDistance:this.sliderValues.clipDistance}}uiElementsUsed="#wall-thickness-slider, #switch-scene-button, #clip-distance-slider";wallThicknessData=[1.55,-.85,1.55];maxClipDistance=15;getNearestCenter(){var e=[this.cameraPos[0]%2,this.cameraPos[1]%2,this.cameraPos[2]%2,1],s=[[1,1,1,1],[1,1,-1,1],[1,-1,1,1],[1,-1,-1,1],[-1,1,1,1],[-1,1,-1,1],[-1,-1,1,1],[-1,-1,-1,1]];let t=1/0,i=0;for(let a=0;a<s.length;a++){var o=magnitude([e[0]-s[a][0],e[1]-s[a][1],e[2]-s[a][2],e[3]-s[a][3]]);o<t&&(t=o,i=a)}return[this.cameraPos[0]-e[0]+s[i][0],this.cameraPos[1]-e[1]+s[i][1],this.cameraPos[2]-e[2]+s[i][2],this.cameraPos[3]-e[3]+s[i][3]]}getNearestCorner(){var e=[this.cameraPos[0]%2,this.cameraPos[1]%2,this.cameraPos[2]%2,1],s=[[0,0,0,1],[0,0,2,1],[0,2,0,1],[0,2,2,1],[2,0,0,1],[2,0,2,1],[2,2,0,1],[2,2,2,1]];let t=1/0,i=0;for(let a=0;a<s.length;a++){var o=magnitude([e[0]-s[a][0],e[1]-s[a][1],e[2]-s[a][2],e[3]-s[a][3]]);o<t&&(t=o,i=a)}return[this.cameraPos[0]-e[0]+s[i][0],this.cameraPos[1]-e[1]+s[i][1],this.cameraPos[2]-e[2]+s[i][2],this.cameraPos[3]-e[3]+s[i][3]]}}export{E3Geometry,E3Axes,E3Rooms};