<header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.webp" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Sorting Algorithms</h1></header><main><section><p class="body-text">How do you sort a long list of numbers? Or, more accurately, how do you instruct a computer to? This question has compelled computer scientists from as early as the 1950s, and dozens upon dozens of algorithms have been created, each with pros and cons. These days, high-level programming languages mostly abstract this away &mdash; in JavaScript, it&#x2019;s as easy as calling <code>array.sort()</code>, and no thought needs to be given to how the sorting should actually be done. This is a very good thing for the most part, but it&#x2019;s interesting &mdash; and often mesmerizing &mdash; to watch particular sorting algorithms do their job, so for this applet, I&#x2019;ve implemented eleven very different ones. The list to be sorted is represented as a color wheel &mdash; presing the Sort button first shuffles it, then sorts it with the method of choice, and then verifies that it has been correctly sorted.</p><p class="body-text">Every algorithm is explained in more detail below, but there are a few general things to mention beforehand. When comparing the speed of algorithms, we need a measurement of time that doesn&#x2019;t depend on the power of the computer running it. Because of this, we typically don&#x2019;t use actual time units, like seconds, but instead something called <strong>big-O notation</strong>. If a sorting algorithm is <span class="tex-holder inline-math" data-source-tex="O(n^2)">$O(n^2)$,</span> then the time it takes to run increases with the square of the amount of data given to it. We may not know how long it will take to sort a list of length 500, but it will take about 4 times as long to sort a list that&#x2019;s twice as long. An algorithm that&#x2019;s <span class="tex-holder inline-math" data-source-tex="O(n)">$O(n)$,</span> on the other hand, will only take about twice the time.</p><p class="body-text">Whenever a sorting algorithm modifies the list, that location in the color wheel (i.e. a thin band) is highlighted, and if it&#x2019;s enabled, a sound is played with pitch based on the number written. All of the algorithms are normalized to take about 20 seconds to complete, regardless of how fast they actually take, so to compare them, look at the number of reads and writes.</p><div class="text-buttons dropdown-holder"><div class="dropdown-container focus-on-child" tabindex="1"><button class="text-button dropdown" type="button" id="algorithms-dropdown-button" tabindex="-1"></button><select id="algorithms-dropdown"></select></div></div><br><p class="body-text info-text" id="bubble-info" style="opacity: 1; display: block">Probably the simplest possible sorting algorithm, bubble sort looks at every adjacent pair of entries and swaps them if they&#x2019;re in the wrong order. It repeats this until it longer sees any pairs it can swap. It runs in $O(n^2)$ time and requires an horribly large number of both reads and writes, making it a worse choice than almost any other algorithm on this list. Its only advantage is how incredibly easy it is to implement.</p><p class="body-text info-text" id="insertion-info">Insertion sort is a step up from bubble sort in a few ways, but it still runs in $O(n^2)$ time. It loops through the list only one time, and slides each entry backward until it&#x2019;s in the correct place among the already-sorted entries. Unfortunately, doing that requires every larger entry to shift forward one place, making the number of writes to the list skyrocket.</p><p class="body-text info-text" id="selection-info">Selection sort is the exact opposite to insertion sort in a sense. It loops through the entire list, finds the smallest entry, and swaps it with the first entry. Then it loops through the list beginning at the second entry, finds the smallest remaining entry, swaps it with the second entry, and so on. Where insertion sort knows what entry it wants to move but not where it needs to go, selection sort knows where its destination is but not which entry it needs to move there. It therefore requires drastically fewer writes but many more reads than insertion sort. It still runs in $O(n^2)$ time &mdash; there&#x2019;s room for improvement.</p><p class="body-text info-text" id="heap-info">Heapsort is the first algorithm on our list that runs in $O(n\log(n))$ time. If you aren&#x2019;t familiar with logarithms or haven&#x2019;t seen them in a while, think of $\log(n)$ as being the exponent of the power of $2$ that&#x2019;s roughly equal to length of the list &mdash; for example, if the list is length 500, $\log(500) \approx 9$, since $2^9 = 512$. It goes without saying that an $O(n\log(n))$ algorithm is <strong>much</strong> faster than an $O(n^2)$ one, and is almost always the better choice. Interestingly, any sorting algorithm that needs to compare entries of the list to see which is larger cannot ever be faster than $O(n\log(n))$. Heapsort functions almost identically to selection sort, but it first arranges its entries into a data structure called a heap. The only requirements for a heap are that every entry is associated with two entries further ahead than it, called its children, and that those children are smaller than it. Since every entry has two children, there are roughly $\log(n)$ levels of the heap, and since every is larger than both its children, the top entry is the largest in the list. We can then remove that top entry and place it at the end of the list, and rearrange the heap to figure out what the new topmost entry should be. It turns out that we only need to move one entry per level to do that, so only $\log(n)$ total. In this sense, selecting the maximum entry only requires looking at $\log(n)$ entries, instead of $n$ as in selection sort.</p><p class="body-text info-text" id="merge-info">Merge sort is another algorithm that runs in $O(n\log(n))$ time, and it&#x2019;s the first recursive algorithm we&#x2019;ve seen. Recursive algorithms work by splitting the list into pieces, breaking those into pieces, and so on, until eventually the pieces are so simple that sorting them is easy. Then they work backward, building the pieces back into a sorted list. Here, every entry is separated from every other, and then the first pair is sorted, followed by the second pair, and so on. Then the first two pairs are interlaced into a sorted length-4 sequence, along with the second two pairs, and the rest. The length-4 sequences are interlaced to create half as many length-8 sequences, and so on until the entire list is sorted. In keeping with the rest of the algorithms, this sort is done <strong>in-place</strong>, meaning it doesn&#x2019;t use extra arrays &mdash; this requires some very careful logic that uses the unsorted parts of the array as working memory to merge the sorted parts.</p><p class="body-text info-text" id="quick-info">Quicksort is one of the most commonly-used algorithms in practice. It&#x2019;s similar to merge sort, but rather than splitting the list in half every time, it first chooses the entry halfway through the list and places smaller entries before it and larger ones after it, resulting in two unevenly-sized blocks. Each of those are then partitioned based on their middle entries in the same way, and the process is repeated until every block is sorted. Like the previous two, it runs in $O(n\log(n))$ time.</p><p class="body-text info-text" id="shell-info">Shellsort is a variant of insertion sort that drastically reduces the distance entries need to move. It begins by taking a large gap size &mdash; say 100 &mdash; and partitioning the array into 100 smaller arrays whose elements are each 100 apart in the original. It then runs insertion sort on each one, and then the gap size is reduced and insertion sort is run again, and we repeat the process until the gap size is 1 and we&#x2019;re just running insertion sort itself. Sorting the larger gap sizes first results in much less shorter distances for insertion sort on the smaller gaps, and the algorithm is such an improvement that it runs in $O(n\log(n))$ time.</p><p class="body-text info-text" id="cycle-info">With most of the common algorithms out of the way, we can look at some stranger ones. Where most algorithms try to minimize the total number of operations, cycle sort only concerns itself with writing to the list as little as possible &mdash; in fact, it only writes once to each location, with the correct entry each time. The idea is that we know exactly where any entry should go &mdash; if there are 102 entries smaller than $x$, then $x$ should be the 103rd entry in the sorted list. So we just put it there and remove whatever was in its place, and repeat the process with that entry. This continues until we get back to where we started, at which point we find the next entry we haven&#x2019;t moved yet. Since the algorithm needs to read <strong>the entire list</strong> every time it moves an entry, it takes $O(n^2)$ time, but for memory devices whose performance degrades quickly when written to, this can be an acceptable tradeoff.</p><p class="body-text info-text" id="msdRadix-info">Where insertion sort is the way most people tend to sort money in a wallet or playing cards in a hand, radix sort is the way you&#x2019;d probably go about sorting words into a dictionary. First put them into 26 different buckets based on their first letter, and then for each bucket, split the words into 26 sub-buckets based on their second letter. Here, we only need two buckets at each level instead of 26, since we sort based on digits in the binary representation of the entries, which are either 0 or 1. MSD stands for most significant digit &mdash; i.e. we sort first based on the first digit, not the last. With $n$ entries to sort and $\log(n)$ binary digits to consider, the algorithm takes $O(n\log(n))$ time. It&#x2019;s also the first algorithm in the list that&#x2019;s not a comparision sort, since entries are never compared against one another, just put into buckets.</p><p class="body-text info-text" id="lsdRadix-info">This is the same algorithm as the previous one, except it makes the strange decision to sort based on the last (least significant) digit first. What results is a progression that appears to be less and less sorted as time goes on, until the final step when everything falls into place like magic. It also runs in $O(n\log(n))$ time.</p><p class="body-text info-text" id="gravity-info">Possibly the strangest algorithm on the list, gravity sort simulates placing the list entries as rows of beads on a vertical abacus, and then letting them fall. The resulting rows at the bottom will be the sorted list. If this is somehow physically simulated, then it will run in $O(\sqrt{n})$ time, since the $n$ rows will all fall at once, and the time for a falling object to hit the ground is proportional to the square root of its starting height. This would crush every other sorting algorithm, but it unfortunately isn&#x2019;t possible to implement in a computer &mdash; the best we can do is moving every bead in a row in a single operation by parallelizing the process, which makes it $O(n)$. The non-parallel version is implemented here, which moves one bead at a time and takes $O(n^2)$ time. Sadly, even with the parallel version, the algorithm requires $O(n^2)$ <strong>memory space</strong> to store the square abacus, and this is prohibitively expensive for large lists.</p><div id="canvas-landscape"><div id="canvas-landscape-left"><div class='text-boxes'><div class="text-box-container"><input id="resolution-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div><div class="text-box-container"><input id="array-size-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div></div><div class='checkboxes'><div class="checkbox-row"><div class="checkbox-container" tabindex="1"><input type="checkbox" id="play-sound-checkbox"><div class="checkbox"></div></div><label for="play-sound-checkbox" style="margin-left: 10px"><p class="body-text checkbox-subtext"></p></label></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="generate-button" tabindex="-1"></button></div></div></div>  <div id="canvas-landscape-middle"><canvas id='output-canvas' class='output-canvas'></canvas></div><div id="canvas-landscape-right"><div><p class="body-text" style="width: 100%; text-align: center; margin-top: 5vh"><code id="num-reads">0</code> reads</p><br><p class="body-text" style="width: 100%; text-align: center"><code id="num-writes">0</code> writes</p></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-button" tabindex="-1"></button></div></div></div></div></section></main>