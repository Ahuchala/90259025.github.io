import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class EllipticCurve extends AnimationFrameApplet{resolution=500;g2=-2;g3=2;constructor({canvas}){super(canvas);var e={shaders:{shader:`
			precision highp float;
			
			varying vec2 uv;
			
			uniform float step;
			
			uniform float g2Arg;
			uniform float g3Arg;
			
			const int maxIterations = 200;
			
			
			
			float f(vec2 z)
			{
				return z.y * z.y   -   z.x * z.x * z.x   -   g2Arg * z.x   -   g3Arg;
			}
			
			
			
			void main(void)
			{
				float threshhold = 4.0 * 1000.0;
				
				vec2 z = uv * 4.0;
				
				
				
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				
				
				
				for (int i = 0; i < maxIterations; i++)
				{
					float score = abs(f(z)) / threshhold;
					
					if (score < 1.0)
					{
						float adjacentScore = (abs(f(z + vec2(step, 0.0))) + abs(f(z - vec2(step, 0.0))) + abs(f(z + vec2(0.0, step))) + abs(f(z - vec2(0.0, step)))) / threshhold;
						
						if (adjacentScore >= 6.0)
						{
							gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
							
							return;
						}
					}
					
					threshhold /= 1.25;
				}
			}
		`,shader2:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			
			uniform float textureStep;
			
			
			
			void main(void)
			{
				//Dilate the pixels to make a thicker line.
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;
				
				float state = (4.0 * texture2D(uTexture, center).y +
				
					texture2D(uTexture, center + vec2(textureStep, 0.0)).y +
					texture2D(uTexture, center - vec2(textureStep, 0.0)).y +
					texture2D(uTexture, center + vec2(0.0, textureStep)).y +
					texture2D(uTexture, center - vec2(0.0, textureStep)).y +
					
					texture2D(uTexture, center + vec2(textureStep, textureStep)).y +
					texture2D(uTexture, center + vec2(textureStep, -textureStep)).y +
					texture2D(uTexture, center + vec2(-textureStep, textureStep)).y +
					texture2D(uTexture, center + vec2(-textureStep, -textureStep)).y
				) / 2.0;
				
				gl_FragColor = vec4(state, state, state, 1.0);
			}
		`},uniforms:{shader:{step:8/this.resolution,g2Arg:this.g2,g3Arg:this.g3},shader2:{textureStep:1/this.resolution}},canvasWidth:this.resolution,worldWidth:8};this.wilson=new WilsonGPU(canvas,e),this.wilson.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilson.useFramebuffer(null),this.resume()}run({g2,g3}){this.g2=g2,this.g3=g3,this.needNewFrame=!0}drawFrame(){this.wilson.useShader("shader"),this.wilson.setUniforms({g2Arg:this.g2,g3Arg:this.g3}),this.wilson.drawFrame();var i=this.wilson.readPixels(),a=[],o=this.resolution,e=this.wilson.canvasWidth;for(let r=2;r<this.wilson.canvasHeight-2;r++)for(let e=2;e<o-2;e++){var t=o*r+e;0!==i[4*t]&&i[4*(t-1)]+i[4*(t+1)]+i[4*(t-o)]+i[4*(t+o)]+i[4*(t-1-o)]+i[4*(t+1-o)]+i[4*(t-1+o)]+i[4*(t+1+o)]<=255&&(t=i[4*(t-2*o-2)]+i[4*(t-2*o-1)]+i[4*(t-2*o)]+i[4*(t-2*o+1)]+i[4*(t-2*o+2)]+i[4*(t+2*o-2)]+i[4*(t+2*o-1)]+i[4*(t+2*o)]+i[4*(t+2*o+1)]+i[4*(t+2*o+2)]+i[4*(t-o-2)]+i[4*(t-2)]+i[4*(t+o-2)]+i[4*(t-o+2)]+i[4*(t+2)]+i[4*(t+o+2)],a.push(0===t?[r,e,!0]:[r,e,!1]))}for(let p=0;p<a.length;p++)if(!(a[p][0]<this.wilson.canvasWidth/20||a[p][1]<this.wilson.canvasHeight/20||a[p][0]>19*this.wilson.canvasWidth/20||a[p][1]>19*this.wilson.canvasHeight/20)){let t=-1,r=e;a[p][2]||(r=e/20);for(let s=0;s<a.length;s++)if(s!==p){var n=Math.sqrt((a[p][0]-a[s][0])*(a[p][0]-a[s][0])+(a[p][1]-a[s][1])*(a[p][1]-a[s][1]));if(n<r&&2<=n){var u,h,l=(a[s][0]-a[p][0])/n*1.414214,c=(a[s][1]-a[p][1])/n*1.414214,l=Math.sign(l)*Math.floor(Math.abs(l)),c=Math.sign(c)*Math.floor(Math.abs(c));let e=0;0==l?(u=o*(a[p][0]+l)+(a[p][1]+c),e+=i[4*u],u=o*(a[p][0]+l+1)+(a[p][1]+c),e+=i[4*u],u=o*(a[p][0]+l-1)+(a[p][1]+c),e+=i[4*u]):0==c?(u=o*(a[p][0]+l)+(a[p][1]+c),e+=i[4*u],u=o*(a[p][0]+l)+(a[p][1]+c+1),e+=i[4*u],u=o*(a[p][0]+l)+(a[p][1]+c-1),e+=i[4*u]):(h=o*(a[p][0]+l)+(a[p][1]+c),e+=i[4*h],h=o*a[p][0]+(a[p][1]+c),e+=i[4*h],h=o*(a[p][0]+l)+a[p][1],e+=i[4*h]),0===e&&(t=s,r=n)}}if(-1!==t)for(let e=1;e<2*r;e++){var f=e/(2*r),f=o*Math.round((1-f)*a[p][0]+f*a[t][0])+Math.round((1-f)*a[p][1]+f*a[t][1]);i[4*f]=0,i[4*f+1]=255,i[4*f+2]=0}}this.wilson.useShader("shader2"),this.wilson.setTexture({id:"0",data:i}),this.wilson.drawFrame()}changeResolution(resolution){this.resolution=resolution,this.wilson.resizeCanvas({width:this.resolution}),this.wilson.setUniforms({step:this.wilson.worldWidth/this.resolution},"shader"),this.wilson.setUniforms({textureStep:1/this.resolution},"shader2"),this.wilson.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilson.useFramebuffer(null),this.needNewFrame=!0}}export{EllipticCurve};