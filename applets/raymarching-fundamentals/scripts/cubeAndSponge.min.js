import{extrudedCubeDE,mengerSpongeDE}from"./distanceEstimators.min.js";import{getRotationMatrix,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class ComposedFractals extends RaymarchApplet{sphereWeight=0;extrudedCubeWeight=1;extrudedCubeSeparation=1.5;mengerSpongeWeight=0;mengerSpongeScale=3;constructor({canvas,useShadows=!1,useReflections=!1,includeSphere=!1,includeExtrudedCube=!1,includeMengerSponge=!1}){super({canvas:canvas,distanceEstimatorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			return min(distanceGround, distanceObject);
		`,getColorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				vec2 co = floor(pos.xy * 50.0);
				return vec3(0.5, 0.5, 0.5)
					* (1.0 + .2 * (rand(co) - .5));
			}

			if (minDistance == distanceObject)
			{
				return getColorObject(pos);
			}
		`,getReflectivityGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				return .05;
			}

			if (minDistance == distanceObject)
			{
				return 0.15;
			}
		`,addGlsl:`
			float rand(vec2 co)
			{
				return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
			}

			${includeSphere?`
				float distanceEstimatorRoomSphere(vec3 pos)
				{
					vec3 modPos = mod(pos, 2.0);
					return 1.25 - length(modPos - vec3(1.0, 1.0, 1.0));
				}

				vec3 getColorRoomSphere(vec3 pos)
				{
					return vec3(0.5, 0.0, 1.0);
				}
			`:""}

			${includeExtrudedCube?`
				${extrudedCubeDE[0]}
				${extrudedCubeDE[1]}
			`:""}

			${includeMengerSponge?`
				${mengerSpongeDE[0]}
				${mengerSpongeDE[1]}
			`:""}

			float distanceEstimatorGround(vec3 pos)
			{
				return abs(pos.z);
			}

			float distanceEstimatorObject(vec3 pos)
			{
				float distanceObject = 0.0;

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));
				
				${includeSphere?`
					if (sphereWeight > 0.0)
					{
						distanceObject += sphereWeight * distanceEstimatorRoomSphere(pos);
					}
				`:""}

				${includeExtrudedCube?`
					if (extrudedCubeWeight > 0.0)
					{
						distanceObject += extrudedCubeWeight * distanceEstimatorExtrudedCube(rotatedPos);
					}
				`:""}

				${includeMengerSponge?`
					if (mengerSpongeWeight > 0.0)
					{
						distanceObject += mengerSpongeWeight * distanceEstimatorMengerSponge(rotatedPos);
					}
				`:""}
				
				return distanceObject;
			}

			vec3 getColorObject(vec3 pos)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));

				${includeSphere?`
					if (sphereWeight > 0.0)
					{
						color += sphereWeight * getColorRoomSphere(pos);
					}
				`:""}

				${includeExtrudedCube?`
					if (extrudedCubeWeight > 0.0)
					{
						color += extrudedCubeWeight * getColorExtrudedCube(rotatedPos);
					}
				`:""}

				${includeMengerSponge?`
					if (mengerSpongeWeight > 0.0)
					{
						color += mengerSpongeWeight * getColorMengerSponge(rotatedPos);
					}
				`:""}

				return color;
			}
		`,uniforms:{objectRotation:["float",0],objectFloat:["float",0],sphereWeight:["float",1],extrudedCubeWeight:["float",0],extrudedCubeSeparation:["float",1.5],mengerSpongeWeight:["float",0],mengerSpongeScale:["float",3],rotationMatrix:["mat3",[[1,0,0],[0,1,0],[0,0,1]]]},maxMarches:192,cameraPos:[1,1,1],theta:1.25*Math.PI,phi:2.1539,lockedOnOrigin:!1,lockZ:1,fogColor:[.6,.73,.87],fogScaling:.075,epsilonScaling:.75,useShadows:useShadows,useReflections:useReflections})}distanceEstimator(){return 1}updateRotationAndFloat(){this.setUniform("objectRotation",this.uniforms.objectRotation[1]+.003),this.setUniform("objectFloat",.1*Math.sin(3*this.uniforms.objectRotation[1])),this.setUniform("rotationMatrix",getRotationMatrix((Math.sin(3*this.uniforms.objectRotation[1]+1.013)+1)/6,(Math.sin(2*this.uniforms.objectRotation[1])+1)/6,(Math.sin(5*this.uniforms.objectRotation[1]+.53)+1)/6)),this.needNewFrame=!0}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed),this.updateRotationAndFloat()}}export{ComposedFractals};