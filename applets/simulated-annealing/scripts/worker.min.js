"use strict";let gridSize,numNodes,maximumSpeed;const initialTemperature=500;let temperature,coolingFactor,nodes=[],currentPath=[];async function drawAnnealingGraph(){nodes=[],currentPath=[],temperature=initialTemperature;let a=0;for(let e=0;e<numNodes;e++)nodes[e]=[Math.floor(Math.random()*gridSize),Math.floor(Math.random()*gridSize)],postMessage([0,nodes[e][1],nodes[e][0],4,[255,0,0]]);for(let t=0;t<numNodes;t++)currentPath[t]=t;for(let n=0;n<numNodes-1;n++)postMessage([1,nodes[n][1],nodes[n][0],nodes[n+1][1],nodes[n+1][0],[255,0,0]]);for(postMessage([1,nodes[numNodes-1][1],nodes[numNodes-1][0],nodes[0][1],nodes[0][0],[255,0,0]]);.001<temperature;){var u=[];u[0]=Math.floor(Math.random()*numNodes),u[1]=Math.floor(Math.random()*(numNodes-1)),u[0]<=u[1]&&u[1]++;let e=0,t=u[0]-1,n=u[0]+1,r=(-1===t&&(t=numNodes-1),n===numNodes&&(n=0),e=(e=(e=(e-=euclideanDistance(currentPath[t],currentPath[u[0]]))+euclideanDistance(currentPath[t],currentPath[u[1]]))-euclideanDistance(currentPath[u[0]],currentPath[n]))+euclideanDistance(currentPath[u[1]],currentPath[n]),t=u[1]-1,n=u[1]+1,-1===t&&(t=numNodes-1),n===numNodes&&(n=0),e=(e=(e=(e-=euclideanDistance(currentPath[t],currentPath[u[1]]))+euclideanDistance(currentPath[t],currentPath[u[0]]))-euclideanDistance(currentPath[u[1]],currentPath[n]))+euclideanDistance(currentPath[u[0]],currentPath[n]),1!==Math.abs(u[0]-u[1])&&Math.abs(u[0]-u[1])!==numNodes-1||(e+=2*euclideanDistance(currentPath[u[0]],currentPath[u[1]])),-1/temperature*e);1e3<r?r=1e3:r<-1e3&&(r=-1e3);var o=Math.min(1,Math.exp(r));Math.random()<o&&(o=currentPath[u[0]],currentPath[u[0]]=currentPath[u[1]],currentPath[u[1]]=o,a++,maximumSpeed||a%(numNodes*numNodes)!=0||await drawLines()),temperature*=1-coolingFactor}temperature=0,drawLines()}function euclideanDistance(node1Index,node2Index){return Math.sqrt((nodes[node1Index][1]-nodes[node2Index][1])**2+(nodes[node1Index][0]-nodes[node2Index][0])**2)}async function drawLines(){postMessage([2]);for(let e=0;e<numNodes;e++)postMessage([0,nodes[e][1],nodes[e][0],4,[255,255*(initialTemperature-temperature)/initialTemperature,255*(initialTemperature-temperature)/initialTemperature]]);for(let t=0;t<numNodes-1;t++)postMessage([1,nodes[currentPath[t]][1],nodes[currentPath[t]][0],nodes[currentPath[t+1]][1],nodes[currentPath[t+1]][0],[255,255*(initialTemperature-temperature)/initialTemperature,255*(initialTemperature-temperature)/initialTemperature]]);postMessage([1,nodes[currentPath[numNodes-1]][1],nodes[currentPath[numNodes-1]][0],nodes[currentPath[0]][1],nodes[currentPath[0]][0],[255,255*(initialTemperature-temperature)/initialTemperature,255*(initialTemperature-temperature)/initialTemperature]]),await new Promise(resolve=>setTimeout(resolve,50))}onmessage=async function(e){gridSize=e.data[0],numNodes=e.data[1],maximumSpeed=e.data[2],coolingFactor=1/(numNodes*numNodes*numNodes),await drawAnnealingGraph()};